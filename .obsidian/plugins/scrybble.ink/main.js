/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
    if (decorator = decorators[i6])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// node_modules/typescript-fsm/dist/stateMachine.js
var require_stateMachine = __commonJS({
  "node_modules/typescript-fsm/dist/stateMachine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyncStateMachine = exports.StateMachine = void 0;
    exports.t = t6;
    function t6(fromState, event, toState, cb) {
      return { fromState, event, toState, cb };
    }
    var StateMachine3 = class {
      // initialize the state-machine
      constructor(init, transitions = [], logger = console) {
        this.init = init;
        this.transitions = transitions;
        this.logger = logger;
        this._current = init;
      }
      addTransitions(transitions) {
        transitions.forEach((_tran) => {
          const tran = Object.create(_tran);
          if (tran.cb && !tran.cb.name?.startsWith("bound ")) {
            tran.cb = tran.cb.bind(this);
          }
          this.transitions.push(tran);
        });
      }
      getState() {
        return this._current;
      }
      can(event) {
        return this.transitions.some((trans) => trans.fromState === this._current && trans.event === event);
      }
      getNextState(event) {
        const transition = this.transitions.find((tran) => tran.fromState === this._current && tran.event === event);
        return transition?.toState;
      }
      isFinal() {
        return this.transitions.every((trans) => trans.fromState !== this._current);
      }
      formatErr(fromState, event) {
        return `No transition: from ${String(fromState)} event ${String(event)}`;
      }
      // post event async
      async dispatch(event, ...args) {
        return new Promise((resolve, reject) => {
          setTimeout((me) => {
            const found = this.transitions.some((tran) => {
              if (tran.fromState === me._current && tran.event === event) {
                me._current = tran.toState;
                if (tran.cb) {
                  try {
                    const p4 = tran.cb(...args);
                    if (p4 instanceof Promise) {
                      p4.then(resolve).catch(reject);
                    } else {
                      resolve();
                    }
                  } catch (e7) {
                    this.logger.error("Exception in callback", e7);
                    reject(e7);
                  }
                } else {
                  resolve();
                }
                return true;
              }
              return false;
            });
            if (!found) {
              const errorMessage = this.formatErr(me._current, event);
              this.logger.error(errorMessage);
              reject(new Error(errorMessage));
            }
          }, 0, this);
        });
      }
      /**
       * Generate a Mermaid StateDiagram of the current machine.
       */
      toMermaid(title) {
        const diagram = [];
        if (title) {
          diagram.push("---");
          diagram.push(`title: ${title}`);
          diagram.push("---");
        }
        diagram.push("stateDiagram-v2");
        diagram.push(`  [*] --> ${String(this.init)}`);
        this.transitions.forEach(({ event, fromState, toState }) => {
          const from = String(fromState);
          const to = String(toState);
          const evt = String(event);
          diagram.push(`  ${from} --> ${to}: ${evt}`);
        });
        const ts = /* @__PURE__ */ new Set();
        this.transitions.forEach(({ toState }) => ts.add(toState));
        this.transitions.forEach(({ fromState }) => ts.delete(fromState));
        ts.forEach((state) => diagram.push(`  ${String(state)} --> [*]`));
        return diagram.join("\n");
      }
    };
    exports.StateMachine = StateMachine3;
    var SyncStateMachine = class extends StateMachine3 {
      constructor(init, transitions = [], logger = console) {
        super(init, transitions, logger);
      }
      dispatch(_event, ..._args) {
        throw new Error("SyncStateMachine does not support async dispatch.");
      }
      // post sync event
      // returns true if the event was handled, false otherwise
      syncDispatch(event, ...args) {
        const found = this.transitions.some((tran) => {
          if (tran.fromState === this._current && tran.event === event) {
            const current = this._current;
            this._current = tran.toState;
            if (tran.cb) {
              try {
                tran.cb(...args);
              } catch (e7) {
                this._current = current;
                this.logger.error("Exception in callback", e7);
                throw e7;
              }
              return true;
            }
            return false;
          }
        });
        if (!found) {
          const errorMessage = this.formatErr(this._current, event);
          this.logger.error(errorMessage);
        }
        return !!found;
      }
    };
    exports.SyncStateMachine = SyncStateMachine;
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module2) {
    "use strict";
    function assertPath(path3) {
      if (typeof path3 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
      }
    }
    function normalizeStringPosix(path3, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i6 = 0; i6 <= path3.length; ++i6) {
        if (i6 < path3.length)
          code = path3.charCodeAt(i6);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i6 - 1 || dots === 1) {
          } else if (lastSlash !== i6 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i6;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i6;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path3.slice(lastSlash + 1, i6);
            else
              res = path3.slice(lastSlash + 1, i6);
            lastSegmentLength = i6 - lastSlash - 1;
          }
          lastSlash = i6;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i6 = arguments.length - 1; i6 >= -1 && !resolvedAbsolute; i6--) {
          var path3;
          if (i6 >= 0)
            path3 = arguments[i6];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path3 = cwd;
          }
          assertPath(path3);
          if (path3.length === 0) {
            continue;
          }
          resolvedPath = path3 + "/" + resolvedPath;
          resolvedAbsolute = path3.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path3) {
        assertPath(path3);
        if (path3.length === 0) return ".";
        var isAbsolute = path3.charCodeAt(0) === 47;
        var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
        path3 = normalizeStringPosix(path3, !isAbsolute);
        if (path3.length === 0 && !isAbsolute) path3 = ".";
        if (path3.length > 0 && trailingSeparator) path3 += "/";
        if (isAbsolute) return "/" + path3;
        return path3;
      },
      isAbsolute: function isAbsolute(path3) {
        assertPath(path3);
        return path3.length > 0 && path3.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i6 = 0; i6 < arguments.length; ++i6) {
          var arg = arguments[i6];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i6 = 0;
        for (; i6 <= length; ++i6) {
          if (i6 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i6) === 47) {
                return to.slice(toStart + i6 + 1);
              } else if (i6 === 0) {
                return to.slice(toStart + i6);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i6) === 47) {
                lastCommonSep = i6;
              } else if (i6 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i6);
          var toCode = to.charCodeAt(toStart + i6);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i6;
        }
        var out = "";
        for (i6 = fromStart + lastCommonSep + 1; i6 <= fromEnd; ++i6) {
          if (i6 === fromEnd || from.charCodeAt(i6) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path3) {
        return path3;
      },
      dirname: function dirname(path3) {
        assertPath(path3);
        if (path3.length === 0) return ".";
        var code = path3.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i6 = path3.length - 1; i6 >= 1; --i6) {
          code = path3.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              end = i6;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path3.slice(0, end);
      },
      basename: function basename2(path3, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path3);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i6;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
          if (ext.length === path3.length && ext === path3) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i6 = path3.length - 1; i6 >= 0; --i6) {
            var code = path3.charCodeAt(i6);
            if (code === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i6 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i6;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path3.length;
          return path3.slice(start, end);
        } else {
          for (i6 = path3.length - 1; i6 >= 0; --i6) {
            if (path3.charCodeAt(i6) === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i6 + 1;
            }
          }
          if (end === -1) return "";
          return path3.slice(start, end);
        }
      },
      extname: function extname(path3) {
        assertPath(path3);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i6 = path3.length - 1; i6 >= 0; --i6) {
          var code = path3.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i6;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path3.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path3) {
        assertPath(path3);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path3.length === 0) return ret;
        var code = path3.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i6 = path3.length - 1;
        var preDotState = 0;
        for (; i6 >= start; --i6) {
          code = path3.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i6;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path3.slice(1, end);
            else ret.base = ret.name = path3.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path3.slice(1, startDot);
            ret.base = path3.slice(1, end);
          } else {
            ret.name = path3.slice(startPart, startDot);
            ret.base = path3.slice(startPart, end);
          }
          ret.ext = path3.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path3.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module2) {
    "use strict";
    function tryStringify(o6) {
      try {
        return JSON.stringify(o6);
      } catch (e7) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f3, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1) return f3;
        var objects = new Array(len);
        objects[0] = ss(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0) return f3;
      var str = "";
      var a3 = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i6 = 0; i6 < flen; ) {
        if (f3.charCodeAt(i6) === 37 && i6 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i6 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i6)
                str += f3.slice(lastPos, i6);
              str += Number(args[a3]);
              lastPos = i6 + 2;
              i6++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null) break;
              if (lastPos < i6)
                str += f3.slice(lastPos, i6);
              str += Math.floor(Number(args[a3]));
              lastPos = i6 + 2;
              i6++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0) break;
              if (lastPos < i6)
                str += f3.slice(lastPos, i6);
              var type = typeof args[a3];
              if (type === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i6 + 2;
                i6++;
                break;
              }
              if (type === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i6 + 2;
                i6++;
                break;
              }
              str += ss(args[a3]);
              lastPos = i6 + 2;
              i6++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i6)
                str += f3.slice(lastPos, i6);
              str += String(args[a3]);
              lastPos = i6 + 2;
              i6++;
              break;
            case 37:
              if (lastPos < i6)
                str += f3.slice(lastPos, i6);
              str += "%";
              lastPos = i6 + 2;
              i6++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i6;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    module2.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function levelToValue(level, logger) {
      return level === "silent" ? Infinity : logger.levels.values[level];
    }
    var baseLogFunctionSymbol = Symbol("pino.logFuncs");
    var hierarchySymbol = Symbol("pino.hierarchy");
    var logFallbackMap = {
      error: "log",
      fatal: "error",
      warn: "error",
      info: "log",
      debug: "log",
      trace: "log"
    };
    function appendChildLogger(parentLogger, childLogger) {
      const newEntry = {
        logger: childLogger,
        parent: parentLogger[hierarchySymbol]
      };
      childLogger[hierarchySymbol] = newEntry;
    }
    function setupBaseLogFunctions(logger, levels, proto) {
      const logFunctions = {};
      levels.forEach((level) => {
        logFunctions[level] = proto[level] ? proto[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop;
      });
      logger[baseLogFunctionSymbol] = logFunctions;
    }
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k2) {
          return k2 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto === "function") {
        levels.forEach(function(level2) {
          proto[level2] = proto;
        });
      }
      if (opts.enabled === false || opts.browser.disabled) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      setupBaseLogFunctions(logger, levels, proto);
      appendChildLogger({}, logger);
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
        formatters: opts.browser.formatters,
        levels,
        timestamp: getTimeFunction(opts),
        messageKey: opts.messageKey || "msg",
        onChild: opts.onChild || noop
      };
      logger.levels = getLevels(opts);
      logger.level = level;
      logger.isLevelEnabled = function(level2) {
        if (!this.levels.values[level2]) {
          return false;
        }
        return this.levels.values[level2] >= this.levels.values[this.level];
      };
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = function(...args) {
        return child.call(this, setOpts, ...args);
      };
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return levelToValue(this.level, this);
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(this, setOpts, logger, "error");
        set(this, setOpts, logger, "fatal");
        set(this, setOpts, logger, "warn");
        set(this, setOpts, logger, "info");
        set(this, setOpts, logger, "debug");
        set(this, setOpts, logger, "trace");
        customLevels.forEach((level3) => {
          set(this, setOpts, logger, level3);
        });
      }
      function child(setOpts2, bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.bindings = bindings;
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        const newLogger = new Child(this);
        appendChildLogger(this, newLogger);
        newLogger.child = function(...args) {
          return child.call(this, setOpts2, ...args);
        };
        newLogger.level = childOptions.level || this.level;
        setOpts2.onChild(newLogger);
        return newLogger;
      }
      return logger;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function getBindingChain(logger) {
      const bindings = [];
      if (logger.bindings) {
        bindings.push(logger.bindings);
      }
      let hierarchy = logger[hierarchySymbol];
      while (hierarchy.parent) {
        hierarchy = hierarchy.parent;
        if (hierarchy.logger.bindings) {
          bindings.push(hierarchy.logger.bindings);
        }
      }
      return bindings.reverse();
    }
    function set(self2, opts, rootLogger, level) {
      Object.defineProperty(self2, level, {
        value: levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop : rootLogger[baseLogFunctionSymbol][level],
        writable: true,
        enumerable: true,
        configurable: true
      });
      if (self2[level] === noop) {
        if (!opts.transmit) return;
        const transmitLevel = opts.transmit.level || self2.level;
        const transmitValue = levelToValue(transmitLevel, rootLogger);
        const methodValue = levelToValue(level, rootLogger);
        if (methodValue < transmitValue) return;
      }
      self2[level] = createWrap(self2, opts, rootLogger, level);
      const bindings = getBindingChain(self2);
      if (bindings.length === 0) {
        return;
      }
      self2[level] = prependBindingsInArguments(bindings, self2[level]);
    }
    function prependBindingsInArguments(bindings, logFunc) {
      return function() {
        return logFunc.apply(this, [...bindings, ...arguments]);
      };
    }
    function createWrap(self2, opts, rootLogger, level) {
      return /* @__PURE__ */ (function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i6 = 0; i6 < args.length; i6++) args[i6] = arguments[i6];
          var argsIsSerialized = false;
          if (opts.serialize) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            argsIsSerialized = true;
          }
          if (opts.asObject || opts.formatters) {
            write.call(proto, ...asObject(this, level, args, ts, opts));
          } else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || self2._level;
            const transmitValue = levelToValue(transmitLevel, rootLogger);
            const methodValue = levelToValue(level, rootLogger);
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
              send: opts.transmit.send,
              val: levelToValue(self2._level, rootLogger)
            }, args, argsIsSerialized);
          }
        };
      })(self2[baseLogFunctionSymbol][level]);
    }
    function asObject(logger, level, args, ts, opts) {
      const {
        level: levelFormatter,
        log: logObjectFormatter = (obj) => obj
      } = opts.formatters || {};
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const logObject = {};
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (ts) {
        logObject.time = ts;
      }
      if (levelFormatter) {
        const formattedLevel = levelFormatter(level, logger.levels.values[level]);
        Object.assign(logObject, formattedLevel);
      } else {
        logObject.level = logger.levels.values[level];
      }
      if (opts.asObjectBindingsOnly) {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
        }
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject, ...argsCloned];
      } else {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
          msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
        } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
        if (msg !== void 0) logObject[opts.messageKey] = msg;
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject];
      }
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i6 in args) {
        if (stdErrSerialize && args[i6] instanceof Error) {
          args[i6] = pino2.stdSerializers.err(args[i6]);
        } else if (typeof args[i6] === "object" && !Array.isArray(args[i6]) && serialize) {
          for (const k2 in args[i6]) {
            if (serialize.indexOf(k2) > -1 && k2 in serializers) {
              args[i6][k2] = serializers[k2](args[i6][k2]);
            }
          }
        }
      }
    }
    function transmit(logger, opts, args, argsIsSerialized = false) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      if (!argsIsSerialized) {
        applySerializers(
          args,
          logger._serialize || Object.keys(logger.serializers),
          logger.serializers,
          logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
        );
      }
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err2) {
      const obj = {
        type: err2.constructor.name,
        msg: err2.message,
        stack: err2.stack
      };
      for (const key in err2) {
        if (obj[key] === void 0) {
          obj[key] = err2[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a3) {
      return a3;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o6) {
        return typeof o6 !== "undefined" && o6;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e7) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
    module2.exports.default = pino2;
    module2.exports.pino = pino2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Scrybble
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var Settings = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Output" });
    new import_obsidian.Setting(containerEl).setName("Output folder").setDesc(`Where your reMarkable files will be stored.
Default is "scrybble/"`).addText((text) => text.setValue(this.plugin.settings.sync_folder).setPlaceholder("scrybble/").onChange(async (value) => {
      this.plugin.settings.sync_folder = value;
      await this.plugin.settings.save();
    }));
    containerEl.createEl("h2", { text: "Scrybble server" });
    new import_obsidian.Setting(containerEl).setName("Self hosted").setDesc("Enable if you host your own Scrybble server").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.self_hosted).onChange(async (value) => {
        this.plugin.settings.self_hosted = value;
        await this.plugin.settings.save();
        this.updateVisibility();
      });
    });
    this.endpointSetting = new import_obsidian.Setting(containerEl).setName("Endpoint").setDesc("Link to a Scrybble server, leave unchanged for the official scrybble.ink server").addText((text) => text.setPlaceholder("http://localhost").setValue(this.plugin.settings.custom_host.endpoint).onChange(async (value) => {
      this.plugin.settings.custom_host.endpoint = value;
      await this.plugin.settings.save();
      this.updateClientFieldsVisibility();
    }));
    this.clientIdSetting = new import_obsidian.Setting(containerEl).setName("Server client ID").addText((text) => {
      text.inputEl.setAttribute("type", "password");
      return text.setValue(this.plugin.settings.custom_host.client_id).onChange(async (value) => {
        this.plugin.settings.custom_host.client_id = value;
        await this.plugin.settings.save();
      });
    });
    this.clientSecretSetting = new import_obsidian.Setting(containerEl).setName("Server client secret").addText((text) => {
      text.inputEl.setAttribute("type", "password");
      return text.setValue(this.plugin.settings.custom_host.client_secret).onChange(async (value) => {
        this.plugin.settings.custom_host.client_secret = value;
        await this.plugin.settings.save();
      });
    });
    this.connectedMessage = containerEl.createEl("p", {
      text: "Connected to the official scrybble server, no additional configuration required."
    });
    this.updateVisibility();
  }
  updateClientFieldsDescription() {
    const endpoint = this.plugin.settings.custom_host.endpoint;
    if (endpoint && endpoint.trim()) {
      const setupUrl = `${endpoint.replace(/\/$/, "")}/self-host-setup`;
      this.clientIdSetting.descEl.innerHTML = `Visit <a href="${setupUrl}" class="external-link">${setupUrl}</a> to get your credentials`;
      this.clientSecretSetting.descEl.innerHTML = `Visit <a href="${setupUrl}" class="external-link">${setupUrl}</a> to get your credentials`;
    } else {
      this.clientIdSetting.descEl.textContent = "Enter the endpoint URL first";
      this.clientSecretSetting.descEl.textContent = "Enter the endpoint URL first";
    }
  }
  updateClientFieldsVisibility() {
    const endpoint = this.plugin.settings.custom_host.endpoint;
    const hasValidEndpoint = endpoint && endpoint.trim() && endpoint.startsWith("http");
    this.clientIdSetting.components.forEach((component) => {
      if ("inputEl" in component) {
        component.inputEl.disabled = !hasValidEndpoint;
      }
    });
    this.clientSecretSetting.components.forEach((component) => {
      if ("inputEl" in component) {
        component.inputEl.disabled = !hasValidEndpoint;
      }
    });
    this.updateClientFieldsDescription();
    if (hasValidEndpoint) {
      this.clientIdSetting.settingEl.style.opacity = "";
      this.clientSecretSetting.settingEl.style.opacity = "";
    } else {
      this.clientIdSetting.settingEl.style.opacity = "0.5";
      this.clientSecretSetting.settingEl.style.opacity = "0.5";
    }
  }
  updateVisibility() {
    if (this.plugin.settings.self_hosted) {
      this.endpointSetting.settingEl.style.display = "";
      this.clientSecretSetting.settingEl.style.display = "";
      this.clientIdSetting.settingEl.style.display = "";
      this.connectedMessage.style.display = "none";
      this.updateClientFieldsVisibility();
    } else {
      this.endpointSetting.settingEl.style.display = "none";
      this.clientSecretSetting.settingEl.style.display = "none";
      this.clientIdSetting.settingEl.style.display = "none";
      this.connectedMessage.style.display = "";
    }
  }
};

// src/ScrybbleView.ts
var import_obsidian4 = require("obsidian");

// node_modules/lit-html/lit-html.js
var t = globalThis;
var i = t.trustedTypes;
var s = i ? i.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
var e = "$lit$";
var h = `lit$${Math.random().toFixed(9).slice(2)}$`;
var o = "?" + h;
var n = `<${o}>`;
var r = document;
var l = () => r.createComment("");
var c = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
var a = Array.isArray;
var u = (t6) => a(t6) || "function" == typeof t6?.[Symbol.iterator];
var d = "[ 	\n\f\r]";
var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y = (t6) => (i6, ...s7) => ({ _$litType$: t6, strings: i6, values: s7 });
var x = y(1);
var b = y(2);
var w = y(3);
var T = Symbol.for("lit-noChange");
var E = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var C = r.createTreeWalker(r, 129);
function P(t6, i6) {
  if (!a(t6) || !t6.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s ? s.createHTML(i6) : i6;
}
var V = (t6, i6) => {
  const s7 = t6.length - 1, o6 = [];
  let r6, l3 = 2 === i6 ? "<svg>" : 3 === i6 ? "<math>" : "", c5 = f;
  for (let i7 = 0; i7 < s7; i7++) {
    const s8 = t6[i7];
    let a3, u3, d3 = -1, y3 = 0;
    for (; y3 < s8.length && (c5.lastIndex = y3, u3 = c5.exec(s8), null !== u3); ) y3 = c5.lastIndex, c5 === f ? "!--" === u3[1] ? c5 = v : void 0 !== u3[1] ? c5 = _ : void 0 !== u3[2] ? ($.test(u3[2]) && (r6 = RegExp("</" + u3[2], "g")), c5 = m) : void 0 !== u3[3] && (c5 = m) : c5 === m ? ">" === u3[0] ? (c5 = r6 ?? f, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c5.lastIndex - u3[2].length, a3 = u3[1], c5 = void 0 === u3[3] ? m : '"' === u3[3] ? g : p) : c5 === g || c5 === p ? c5 = m : c5 === v || c5 === _ ? c5 = f : (c5 = m, r6 = void 0);
    const x2 = c5 === m && t6[i7 + 1].startsWith("/>") ? " " : "";
    l3 += c5 === f ? s8 + n : d3 >= 0 ? (o6.push(a3), s8.slice(0, d3) + e + s8.slice(d3) + h + x2) : s8 + h + (-2 === d3 ? i7 : x2);
  }
  return [P(t6, l3 + (t6[s7] || "<?>") + (2 === i6 ? "</svg>" : 3 === i6 ? "</math>" : "")), o6];
};
var N = class _N {
  constructor({ strings: t6, _$litType$: s7 }, n7) {
    let r6;
    this.parts = [];
    let c5 = 0, a3 = 0;
    const u3 = t6.length - 1, d3 = this.parts, [f3, v2] = V(t6, s7);
    if (this.el = _N.createElement(f3, n7), C.currentNode = this.el.content, 2 === s7 || 3 === s7) {
      const t7 = this.el.content.firstChild;
      t7.replaceWith(...t7.childNodes);
    }
    for (; null !== (r6 = C.nextNode()) && d3.length < u3; ) {
      if (1 === r6.nodeType) {
        if (r6.hasAttributes()) for (const t7 of r6.getAttributeNames()) if (t7.endsWith(e)) {
          const i6 = v2[a3++], s8 = r6.getAttribute(t7).split(h), e7 = /([.?@])?(.*)/.exec(i6);
          d3.push({ type: 1, index: c5, name: e7[2], strings: s8, ctor: "." === e7[1] ? H : "?" === e7[1] ? I : "@" === e7[1] ? L : k }), r6.removeAttribute(t7);
        } else t7.startsWith(h) && (d3.push({ type: 6, index: c5 }), r6.removeAttribute(t7));
        if ($.test(r6.tagName)) {
          const t7 = r6.textContent.split(h), s8 = t7.length - 1;
          if (s8 > 0) {
            r6.textContent = i ? i.emptyScript : "";
            for (let i6 = 0; i6 < s8; i6++) r6.append(t7[i6], l()), C.nextNode(), d3.push({ type: 2, index: ++c5 });
            r6.append(t7[s8], l());
          }
        }
      } else if (8 === r6.nodeType) if (r6.data === o) d3.push({ type: 2, index: c5 });
      else {
        let t7 = -1;
        for (; -1 !== (t7 = r6.data.indexOf(h, t7 + 1)); ) d3.push({ type: 7, index: c5 }), t7 += h.length - 1;
      }
      c5++;
    }
  }
  static createElement(t6, i6) {
    const s7 = r.createElement("template");
    return s7.innerHTML = t6, s7;
  }
};
function S(t6, i6, s7 = t6, e7) {
  if (i6 === T) return i6;
  let h3 = void 0 !== e7 ? s7._$Co?.[e7] : s7._$Cl;
  const o6 = c(i6) ? void 0 : i6._$litDirective$;
  return h3?.constructor !== o6 && (h3?._$AO?.(false), void 0 === o6 ? h3 = void 0 : (h3 = new o6(t6), h3._$AT(t6, s7, e7)), void 0 !== e7 ? (s7._$Co ??= [])[e7] = h3 : s7._$Cl = h3), void 0 !== h3 && (i6 = S(t6, h3._$AS(t6, i6.values), h3, e7)), i6;
}
var M = class {
  constructor(t6, i6) {
    this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i6;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t6) {
    const { el: { content: i6 }, parts: s7 } = this._$AD, e7 = (t6?.creationScope ?? r).importNode(i6, true);
    C.currentNode = e7;
    let h3 = C.nextNode(), o6 = 0, n7 = 0, l3 = s7[0];
    for (; void 0 !== l3; ) {
      if (o6 === l3.index) {
        let i7;
        2 === l3.type ? i7 = new R(h3, h3.nextSibling, this, t6) : 1 === l3.type ? i7 = new l3.ctor(h3, l3.name, l3.strings, this, t6) : 6 === l3.type && (i7 = new z(h3, this, t6)), this._$AV.push(i7), l3 = s7[++n7];
      }
      o6 !== l3?.index && (h3 = C.nextNode(), o6++);
    }
    return C.currentNode = r, e7;
  }
  p(t6) {
    let i6 = 0;
    for (const s7 of this._$AV) void 0 !== s7 && (void 0 !== s7.strings ? (s7._$AI(t6, s7, i6), i6 += s7.strings.length - 2) : s7._$AI(t6[i6])), i6++;
  }
};
var R = class _R {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t6, i6, s7, e7) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t6, this._$AB = i6, this._$AM = s7, this.options = e7, this._$Cv = e7?.isConnected ?? true;
  }
  get parentNode() {
    let t6 = this._$AA.parentNode;
    const i6 = this._$AM;
    return void 0 !== i6 && 11 === t6?.nodeType && (t6 = i6.parentNode), t6;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t6, i6 = this) {
    t6 = S(this, t6, i6), c(t6) ? t6 === E || null == t6 || "" === t6 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t6 !== this._$AH && t6 !== T && this._(t6) : void 0 !== t6._$litType$ ? this.$(t6) : void 0 !== t6.nodeType ? this.T(t6) : u(t6) ? this.k(t6) : this._(t6);
  }
  O(t6) {
    return this._$AA.parentNode.insertBefore(t6, this._$AB);
  }
  T(t6) {
    this._$AH !== t6 && (this._$AR(), this._$AH = this.O(t6));
  }
  _(t6) {
    this._$AH !== E && c(this._$AH) ? this._$AA.nextSibling.data = t6 : this.T(r.createTextNode(t6)), this._$AH = t6;
  }
  $(t6) {
    const { values: i6, _$litType$: s7 } = t6, e7 = "number" == typeof s7 ? this._$AC(t6) : (void 0 === s7.el && (s7.el = N.createElement(P(s7.h, s7.h[0]), this.options)), s7);
    if (this._$AH?._$AD === e7) this._$AH.p(i6);
    else {
      const t7 = new M(e7, this), s8 = t7.u(this.options);
      t7.p(i6), this.T(s8), this._$AH = t7;
    }
  }
  _$AC(t6) {
    let i6 = A.get(t6.strings);
    return void 0 === i6 && A.set(t6.strings, i6 = new N(t6)), i6;
  }
  k(t6) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i6 = this._$AH;
    let s7, e7 = 0;
    for (const h3 of t6) e7 === i6.length ? i6.push(s7 = new _R(this.O(l()), this.O(l()), this, this.options)) : s7 = i6[e7], s7._$AI(h3), e7++;
    e7 < i6.length && (this._$AR(s7 && s7._$AB.nextSibling, e7), i6.length = e7);
  }
  _$AR(t6 = this._$AA.nextSibling, i6) {
    for (this._$AP?.(false, true, i6); t6 !== this._$AB; ) {
      const i7 = t6.nextSibling;
      t6.remove(), t6 = i7;
    }
  }
  setConnected(t6) {
    void 0 === this._$AM && (this._$Cv = t6, this._$AP?.(t6));
  }
};
var k = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t6, i6, s7, e7, h3) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t6, this.name = i6, this._$AM = e7, this.options = h3, s7.length > 2 || "" !== s7[0] || "" !== s7[1] ? (this._$AH = Array(s7.length - 1).fill(new String()), this.strings = s7) : this._$AH = E;
  }
  _$AI(t6, i6 = this, s7, e7) {
    const h3 = this.strings;
    let o6 = false;
    if (void 0 === h3) t6 = S(this, t6, i6, 0), o6 = !c(t6) || t6 !== this._$AH && t6 !== T, o6 && (this._$AH = t6);
    else {
      const e8 = t6;
      let n7, r6;
      for (t6 = h3[0], n7 = 0; n7 < h3.length - 1; n7++) r6 = S(this, e8[s7 + n7], i6, n7), r6 === T && (r6 = this._$AH[n7]), o6 ||= !c(r6) || r6 !== this._$AH[n7], r6 === E ? t6 = E : t6 !== E && (t6 += (r6 ?? "") + h3[n7 + 1]), this._$AH[n7] = r6;
    }
    o6 && !e7 && this.j(t6);
  }
  j(t6) {
    t6 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t6 ?? "");
  }
};
var H = class extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t6) {
    this.element[this.name] = t6 === E ? void 0 : t6;
  }
};
var I = class extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t6) {
    this.element.toggleAttribute(this.name, !!t6 && t6 !== E);
  }
};
var L = class extends k {
  constructor(t6, i6, s7, e7, h3) {
    super(t6, i6, s7, e7, h3), this.type = 5;
  }
  _$AI(t6, i6 = this) {
    if ((t6 = S(this, t6, i6, 0) ?? E) === T) return;
    const s7 = this._$AH, e7 = t6 === E && s7 !== E || t6.capture !== s7.capture || t6.once !== s7.once || t6.passive !== s7.passive, h3 = t6 !== E && (s7 === E || e7);
    e7 && this.element.removeEventListener(this.name, this, s7), h3 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
  }
  handleEvent(t6) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t6) : this._$AH.handleEvent(t6);
  }
};
var z = class {
  constructor(t6, i6, s7) {
    this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s7;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t6) {
    S(this, t6);
  }
};
var j = t.litHtmlPolyfillSupport;
j?.(N, R), (t.litHtmlVersions ??= []).push("3.3.1");
var B = (t6, i6, s7) => {
  const e7 = s7?.renderBefore ?? i6;
  let h3 = e7._$litPart$;
  if (void 0 === h3) {
    const t7 = s7?.renderBefore ?? null;
    e7._$litPart$ = h3 = new R(i6.insertBefore(l(), t7), t7, void 0, s7 ?? {});
  }
  return h3._$AI(t6), h3;
};

// src/FileNavigator.ts
var import_obsidian2 = require("obsidian");
var ObsidianFileNavigator = class {
  constructor(app) {
    this.app = app;
  }
  async openInNewTab(filePath) {
    const file = this.app.vault.getFileByPath(filePath);
    if (file) await this.app.workspace.getLeaf(true).openFile(file);
  }
  async openInVerticalSplit(filePath) {
    const file = this.app.vault.getFileByPath(filePath);
    if (file) {
      await this.app.workspace.getLeaf("split", "vertical").openFile(file);
    }
  }
  async openInHorizontalSplit(filePath) {
    const file = this.app.vault.getFileByPath(filePath);
    if (file) {
      await this.app.workspace.getLeaf("split", "horizontal").openFile(file);
    }
  }
  getFileByPath(path3) {
    return this.app.vault.getFileByPath(path3);
  }
  showContextMenu(event, items) {
    const menu = new import_obsidian2.Menu();
    items.forEach((item) => {
      if (item.isSeparator) {
        menu.addSeparator();
      } else {
        menu.addItem((menuItem) => {
          menuItem.setTitle(item.title).setIcon(item.icon).setDisabled(item.disabled || false);
          if (item.onClick) {
            menuItem.onClick(item.onClick);
          }
        });
      }
    });
    menu.showAtMouseEvent(event);
  }
};

// src/ui/Components/FileSyncFeedbackModal.ts
var import_obsidian3 = require("obsidian");
var FileSyncFeedbackModal = class extends import_obsidian3.Modal {
  constructor(app, syncFile, onSubmit) {
    super(app);
    this.syncFile = syncFile;
    this.onSubmit = onSubmit;
    this.devAccess = false;
    this.openAccess = false;
    this.comment = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.syncFile.sync?.error) {
      this.setTitle("Your reMarkable document isn't syncing well. Need help?");
    } else {
      this.setTitle("Got feedback about this document? Let us know!");
    }
    new import_obsidian3.Setting(contentEl).setHeading().setName("Your privacy matters").setDesc("The Scrybble developers cannot just access your documents.");
    new import_obsidian3.Setting(contentEl).setName("Allow the developer to access this reMarkable file").addToggle((toggle) => toggle.setValue(this.devAccess).onChange((value) => {
      this.devAccess = value;
      if (!value) {
        this.openAccess = false;
        this.openAccessSetting.setValue(false);
      }
      this.updateVisibility();
      this.updateShareInfo();
      this.updateButtonState();
    }));
    new import_obsidian3.Setting(contentEl).setName("Share with the wider reMarkable development community").setDesc("Sharing your document with everyone may feel strange, but Scrybble and the reMarkable development community is built on open principles. When you share with the wider community, any developer can use it to make sure their application works well for you. Want a thriving community of tools for the reMarkable? You can contribute!").addToggle((toggle) => {
      this.openAccessSetting = toggle;
      return toggle.setValue(this.openAccess).onChange((value) => {
        this.openAccess = value;
        this.updateShareInfo();
      });
    });
    this.commentSetting = new import_obsidian3.Setting(contentEl).setName("What's up with this document?").addTextArea((text) => text.setPlaceholder("I expected [...] but [...] happened instead").onChange((value) => {
      this.comment = value;
      this.updateButtonState();
    }));
    this.whatWillBeShared = new import_obsidian3.Setting(contentEl).setName("What will be shared?");
    this.whoWillBeSharedWith = new import_obsidian3.Setting(contentEl).setName("Who will it be shared with?");
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      this.shareButton = btn;
      return btn.setButtonText("Share this document").setCta().setDisabled(true).onClick(this.handleShare.bind(this));
    }).addButton((btn) => btn.setButtonText("Don't share").onClick(this.close.bind(this)));
    this.updateVisibility();
    this.updateShareInfo();
  }
  updateVisibility() {
    this.openAccessSetting.toggleEl.style.display = this.devAccess ? "" : "none";
    this.commentSetting.settingEl.style.display = this.devAccess ? "" : "none";
  }
  updateShareInfo() {
    let whatDesc;
    if (this.devAccess) {
      const items = [];
      if (this.syncFile.sync?.error) {
        items.push("The errors associated with this reMarkable document, PDF or quick sheets");
      }
      items.push(`Your reMarkable document: ${this.syncFile.name}`);
      whatDesc = items.join("\n\u2022 ");
      whatDesc = "\u2022 " + whatDesc;
    } else {
      whatDesc = "Nothing. You haven't given permission to share.";
    }
    this.whatWillBeShared.setDesc(whatDesc);
    let whoDesc;
    if (this.devAccess && this.openAccess) {
      whoDesc = "This document will be shared with anyone.";
    } else if (this.devAccess && !this.openAccess) {
      whoDesc = "This document will be shared with the developer(s) of Scrybble.";
    } else {
      whoDesc = "Nobody. You haven't given permission to share.";
    }
    this.whoWillBeSharedWith.setDesc(whoDesc);
  }
  updateButtonState() {
    this.shareButton.setDisabled(!this.devAccess || this.comment.length === 0);
  }
  async handleShare() {
    const details = {
      developer_access_consent_granted: this.devAccess,
      open_access_consent_granted: this.openAccess,
      sync_id: this.syncFile.sync.id
    };
    if (this.comment.trim()) {
      details.feedback = this.comment.trim();
    }
    try {
      await this.onSubmit(details);
      new import_obsidian3.Notice("Shared reMarkable document.");
      this.close();
    } catch (error) {
      new import_obsidian3.Notice("Was unable to share the reMarkable document. Contact developer.");
      console.error("Share error:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ScrybbleView.ts
var SCRYBBLE_VIEW = "SCRYBBLE_VIEW";
var ScrybbleView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.navigation = true;
    this.plugin = plugin;
  }
  async onload() {
    this.setupContainerStyles();
    await this.renderView();
  }
  getDisplayText() {
    return "Scrybble";
  }
  getViewType() {
    return SCRYBBLE_VIEW;
  }
  getIcon() {
    return "pencil-line";
  }
  setupContainerStyles() {
    this.contentEl.style.display = "flex";
    this.contentEl.style.flexDirection = "column";
  }
  async handleViewSwitch(view) {
    await this.renderView();
  }
  async handleErrorRefresh() {
    await this.renderView();
  }
  async renderView() {
    const self2 = this;
    const scrybble = {
      api: this.plugin,
      get sync() {
        return self2.plugin.syncQueue;
      },
      get settings() {
        return self2.plugin.settings;
      },
      fileNavigator: new ObsidianFileNavigator(this.plugin.app),
      get authentication() {
        return self2.plugin.authentication;
      },
      meta: {
        scrybbleVersion: this.plugin.manifest.version,
        obsidianVersion: import_obsidian4.apiVersion,
        platformInfo: this.getPlatformInfo()
      },
      openFeedbackDialog: (syncFile, onSubmit) => {
        const dialog = new FileSyncFeedbackModal(self2.plugin.app, syncFile, onSubmit);
        dialog.open();
      }
    };
    B(x`
			<scrybble-ui .scrybble="${scrybble}"
						 .onViewSwitch="${this.handleViewSwitch.bind(this)}"
						 .onErrorRefresh="${this.handleErrorRefresh.bind(this)}"
			/>`, this.contentEl);
  }
  getPlatformInfo() {
    const p4 = import_obsidian4.Platform;
    const appType = p4.isDesktopApp ? "Desktop" : "Mobile";
    let os = "Unknown";
    if (p4.isMacOS) os = "macOS";
    else if (p4.isWin) os = "Windows";
    else if (p4.isLinux) os = "Linux";
    else if (p4.isIosApp) os = "iOS";
    else if (p4.isAndroidApp) os = "Android";
    const formFactor = p4.isMobile ? p4.isPhone ? " (Phone)" : p4.isTablet ? " (Tablet)" : "" : "";
    return `${appType} - ${os}${formFactor}`;
  }
};

// node_modules/@lit/reactive-element/css-tag.js
var t2 = globalThis;
var e2 = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s2 = Symbol();
var o2 = /* @__PURE__ */ new WeakMap();
var n2 = class {
  constructor(t6, e7, o6) {
    if (this._$cssResult$ = true, o6 !== s2) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t6, this.t = e7;
  }
  get styleSheet() {
    let t6 = this.o;
    const s7 = this.t;
    if (e2 && void 0 === t6) {
      const e7 = void 0 !== s7 && 1 === s7.length;
      e7 && (t6 = o2.get(s7)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e7 && o2.set(s7, t6));
    }
    return t6;
  }
  toString() {
    return this.cssText;
  }
};
var r2 = (t6) => new n2("string" == typeof t6 ? t6 : t6 + "", void 0, s2);
var S2 = (s7, o6) => {
  if (e2) s7.adoptedStyleSheets = o6.map(((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet));
  else for (const e7 of o6) {
    const o7 = document.createElement("style"), n7 = t2.litNonce;
    void 0 !== n7 && o7.setAttribute("nonce", n7), o7.textContent = e7.cssText, s7.appendChild(o7);
  }
};
var c2 = e2 ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
  let e7 = "";
  for (const s7 of t7.cssRules) e7 += s7.cssText;
  return r2(e7);
})(t6) : t6;

// node_modules/@lit/reactive-element/reactive-element.js
var { is: i3, defineProperty: e3, getOwnPropertyDescriptor: h2, getOwnPropertyNames: r3, getOwnPropertySymbols: o3, getPrototypeOf: n3 } = Object;
var a2 = globalThis;
var c3 = a2.trustedTypes;
var l2 = c3 ? c3.emptyScript : "";
var p2 = a2.reactiveElementPolyfillSupport;
var d2 = (t6, s7) => t6;
var u2 = { toAttribute(t6, s7) {
  switch (s7) {
    case Boolean:
      t6 = t6 ? l2 : null;
      break;
    case Object:
    case Array:
      t6 = null == t6 ? t6 : JSON.stringify(t6);
  }
  return t6;
}, fromAttribute(t6, s7) {
  let i6 = t6;
  switch (s7) {
    case Boolean:
      i6 = null !== t6;
      break;
    case Number:
      i6 = null === t6 ? null : Number(t6);
      break;
    case Object:
    case Array:
      try {
        i6 = JSON.parse(t6);
      } catch (t7) {
        i6 = null;
      }
  }
  return i6;
} };
var f2 = (t6, s7) => !i3(t6, s7);
var b2 = { attribute: true, type: String, converter: u2, reflect: false, useDefault: false, hasChanged: f2 };
Symbol.metadata ??= Symbol("metadata"), a2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var y2 = class extends HTMLElement {
  static addInitializer(t6) {
    this._$Ei(), (this.l ??= []).push(t6);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t6, s7 = b2) {
    if (s7.state && (s7.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t6) && ((s7 = Object.create(s7)).wrapped = true), this.elementProperties.set(t6, s7), !s7.noAccessor) {
      const i6 = Symbol(), h3 = this.getPropertyDescriptor(t6, i6, s7);
      void 0 !== h3 && e3(this.prototype, t6, h3);
    }
  }
  static getPropertyDescriptor(t6, s7, i6) {
    const { get: e7, set: r6 } = h2(this.prototype, t6) ?? { get() {
      return this[s7];
    }, set(t7) {
      this[s7] = t7;
    } };
    return { get: e7, set(s8) {
      const h3 = e7?.call(this);
      r6?.call(this, s8), this.requestUpdate(t6, h3, i6);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t6) {
    return this.elementProperties.get(t6) ?? b2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d2("elementProperties"))) return;
    const t6 = n3(this);
    t6.finalize(), void 0 !== t6.l && (this.l = [...t6.l]), this.elementProperties = new Map(t6.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d2("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d2("properties"))) {
      const t7 = this.properties, s7 = [...r3(t7), ...o3(t7)];
      for (const i6 of s7) this.createProperty(i6, t7[i6]);
    }
    const t6 = this[Symbol.metadata];
    if (null !== t6) {
      const s7 = litPropertyMetadata.get(t6);
      if (void 0 !== s7) for (const [t7, i6] of s7) this.elementProperties.set(t7, i6);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t7, s7] of this.elementProperties) {
      const i6 = this._$Eu(t7, s7);
      void 0 !== i6 && this._$Eh.set(i6, t7);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s7) {
    const i6 = [];
    if (Array.isArray(s7)) {
      const e7 = new Set(s7.flat(1 / 0).reverse());
      for (const s8 of e7) i6.unshift(c2(s8));
    } else void 0 !== s7 && i6.push(c2(s7));
    return i6;
  }
  static _$Eu(t6, s7) {
    const i6 = s7.attribute;
    return false === i6 ? void 0 : "string" == typeof i6 ? i6 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t6) => this.enableUpdating = t6)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t6) => t6(this)));
  }
  addController(t6) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t6), void 0 !== this.renderRoot && this.isConnected && t6.hostConnected?.();
  }
  removeController(t6) {
    this._$EO?.delete(t6);
  }
  _$E_() {
    const t6 = /* @__PURE__ */ new Map(), s7 = this.constructor.elementProperties;
    for (const i6 of s7.keys()) this.hasOwnProperty(i6) && (t6.set(i6, this[i6]), delete this[i6]);
    t6.size > 0 && (this._$Ep = t6);
  }
  createRenderRoot() {
    const t6 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S2(t6, this.constructor.elementStyles), t6;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach(((t6) => t6.hostConnected?.()));
  }
  enableUpdating(t6) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t6) => t6.hostDisconnected?.()));
  }
  attributeChangedCallback(t6, s7, i6) {
    this._$AK(t6, i6);
  }
  _$ET(t6, s7) {
    const i6 = this.constructor.elementProperties.get(t6), e7 = this.constructor._$Eu(t6, i6);
    if (void 0 !== e7 && true === i6.reflect) {
      const h3 = (void 0 !== i6.converter?.toAttribute ? i6.converter : u2).toAttribute(s7, i6.type);
      this._$Em = t6, null == h3 ? this.removeAttribute(e7) : this.setAttribute(e7, h3), this._$Em = null;
    }
  }
  _$AK(t6, s7) {
    const i6 = this.constructor, e7 = i6._$Eh.get(t6);
    if (void 0 !== e7 && this._$Em !== e7) {
      const t7 = i6.getPropertyOptions(e7), h3 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== t7.converter?.fromAttribute ? t7.converter : u2;
      this._$Em = e7, this[e7] = h3.fromAttribute(s7, t7.type) ?? this._$Ej?.get(e7) ?? null, this._$Em = null;
    }
  }
  requestUpdate(t6, s7, i6) {
    if (void 0 !== t6) {
      const e7 = this.constructor, h3 = this[t6];
      if (i6 ??= e7.getPropertyOptions(t6), !((i6.hasChanged ?? f2)(h3, s7) || i6.useDefault && i6.reflect && h3 === this._$Ej?.get(t6) && !this.hasAttribute(e7._$Eu(t6, i6)))) return;
      this.C(t6, s7, i6);
    }
    false === this.isUpdatePending && (this._$ES = this._$EP());
  }
  C(t6, s7, { useDefault: i6, reflect: e7, wrapped: h3 }, r6) {
    i6 && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t6) && (this._$Ej.set(t6, r6 ?? s7 ?? this[t6]), true !== h3 || void 0 !== r6) || (this._$AL.has(t6) || (this.hasUpdated || i6 || (s7 = void 0), this._$AL.set(t6, s7)), true === e7 && this._$Em !== t6 && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t6));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t7) {
      Promise.reject(t7);
    }
    const t6 = this.scheduleUpdate();
    return null != t6 && await t6, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t8, s8] of this._$Ep) this[t8] = s8;
        this._$Ep = void 0;
      }
      const t7 = this.constructor.elementProperties;
      if (t7.size > 0) for (const [s8, i6] of t7) {
        const { wrapped: t8 } = i6, e7 = this[s8];
        true !== t8 || this._$AL.has(s8) || void 0 === e7 || this.C(s8, void 0, i6, e7);
      }
    }
    let t6 = false;
    const s7 = this._$AL;
    try {
      t6 = this.shouldUpdate(s7), t6 ? (this.willUpdate(s7), this._$EO?.forEach(((t7) => t7.hostUpdate?.())), this.update(s7)) : this._$EM();
    } catch (s8) {
      throw t6 = false, this._$EM(), s8;
    }
    t6 && this._$AE(s7);
  }
  willUpdate(t6) {
  }
  _$AE(t6) {
    this._$EO?.forEach(((t7) => t7.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t6) {
    return true;
  }
  update(t6) {
    this._$Eq &&= this._$Eq.forEach(((t7) => this._$ET(t7, this[t7]))), this._$EM();
  }
  updated(t6) {
  }
  firstUpdated(t6) {
  }
};
y2.elementStyles = [], y2.shadowRootOptions = { mode: "open" }, y2[d2("elementProperties")] = /* @__PURE__ */ new Map(), y2[d2("finalized")] = /* @__PURE__ */ new Map(), p2?.({ ReactiveElement: y2 }), (a2.reactiveElementVersions ??= []).push("2.1.0");

// node_modules/lit-element/lit-element.js
var s3 = globalThis;
var i4 = class extends y2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t6 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t6.firstChild, t6;
  }
  update(t6) {
    const r6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this._$Do = B(r6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return T;
  }
};
i4._$litElement$ = true, i4["finalized"] = true, s3.litElementHydrateSupport?.({ LitElement: i4 });
var o4 = s3.litElementPolyfillSupport;
o4?.({ LitElement: i4 });
(s3.litElementVersions ??= []).push("4.2.1");

// node_modules/@lit/reactive-element/decorators/property.js
var o5 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f2 };
var r4 = (t6 = o5, e7, r6) => {
  const { kind: n7, metadata: i6 } = r6;
  let s7 = globalThis.litPropertyMetadata.get(i6);
  if (void 0 === s7 && globalThis.litPropertyMetadata.set(i6, s7 = /* @__PURE__ */ new Map()), "setter" === n7 && ((t6 = Object.create(t6)).wrapped = true), s7.set(r6.name, t6), "accessor" === n7) {
    const { name: o6 } = r6;
    return { set(r7) {
      const n8 = e7.get.call(this);
      e7.set.call(this, r7), this.requestUpdate(o6, n8, t6);
    }, init(e8) {
      return void 0 !== e8 && this.C(o6, void 0, t6, e8), e8;
    } };
  }
  if ("setter" === n7) {
    const { name: o6 } = r6;
    return function(r7) {
      const n8 = this[o6];
      e7.call(this, r7), this.requestUpdate(o6, n8, t6);
    };
  }
  throw Error("Unsupported decorator location: " + n7);
};
function n5(t6) {
  return (e7, o6) => "object" == typeof o6 ? r4(t6, e7, o6) : ((t7, e8, o7) => {
    const r6 = e8.hasOwnProperty(o7);
    return e8.constructor.createProperty(o7, t7), r6 ? Object.getOwnPropertyDescriptor(e8, o7) : void 0;
  })(t6, e7, o6);
}

// node_modules/@lit/reactive-element/decorators/state.js
function r5(r6) {
  return n5({ ...r6, state: true, attribute: false });
}

// src/ui/Components/RmDir.ts
var import_obsidian5 = require("obsidian");
var RmDir = class extends i4 {
  render() {
    return x` <div class="tree-item" @click="${this._handleClick}" aria-label="Open folder">
				<div class="tree-item-self is-clickable">
					<span class="tree-item-icon">${(0, import_obsidian5.getIcon)("folder")}</span> ${this.directory.name}
				</div>
			</div>
		`;
  }
  createRenderRoot() {
    return this;
  }
  _handleClick() {
    this.dispatchEvent(new CustomEvent("rm-click", {
      detail: { name: this.directory.name, path: this.directory.path, type: "d" },
      bubbles: true,
      composed: true
    }));
  }
};
__decorateClass([
  n5({ type: Object })
], RmDir.prototype, "directory", 2);

// src/ui/Components/RmFile.ts
var import_obsidian7 = require("obsidian");

// src/support.ts
function dirPath(filePath) {
  const atoms = filePath.split("/");
  const dirs = atoms.slice(0, atoms.length - 1);
  return dirs.filter((a3) => Boolean(a3)).join("/") + "/";
}
function basename(filePath) {
  const atoms = filePath.split("/");
  return atoms[atoms.length - 1];
}
function sanitizeFilename(filePath, ignoreSlashes = false) {
  const tokens = ["*", '"', "\\", "<", ">", ":", "|", "?"];
  if (!ignoreSlashes) {
    tokens.push("/");
  }
  tokens.forEach((token) => {
    const regex = new RegExp("\\" + token, "g");
    filePath = filePath.replace(regex, "_");
  });
  return filePath;
}

// node_modules/@lit/context/lib/context-request-event.js
var s4 = class extends Event {
  constructor(s7, t6, e7, o6) {
    super("context-request", { bubbles: true, composed: true }), this.context = s7, this.contextTarget = t6, this.callback = e7, this.subscribe = o6 ?? false;
  }
};

// node_modules/@lit/context/lib/create-context.js
function n6(n7) {
  return n7;
}

// node_modules/@lit/context/lib/controllers/context-consumer.js
var s5 = class {
  constructor(t6, s7, i6, h3) {
    if (this.subscribe = false, this.provided = false, this.value = void 0, this.t = (t7, s8) => {
      this.unsubscribe && (this.unsubscribe !== s8 && (this.provided = false, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = t7, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = true, this.callback && this.callback(t7, s8)), this.unsubscribe = s8;
    }, this.host = t6, void 0 !== s7.context) {
      const t7 = s7;
      this.context = t7.context, this.callback = t7.callback, this.subscribe = t7.subscribe ?? false;
    } else this.context = s7, this.callback = i6, this.subscribe = h3 ?? false;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new s4(this.context, this.host, this.t, this.subscribe));
  }
};

// node_modules/@lit/context/lib/value-notifier.js
var s6 = class {
  get value() {
    return this.o;
  }
  set value(s7) {
    this.setValue(s7);
  }
  setValue(s7, t6 = false) {
    const i6 = t6 || !Object.is(s7, this.o);
    this.o = s7, i6 && this.updateObservers();
  }
  constructor(s7) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [s8, { disposer: t6 }] of this.subscriptions) s8(this.o, t6);
    }, void 0 !== s7 && (this.value = s7);
  }
  addCallback(s7, t6, i6) {
    if (!i6) return void s7(this.value);
    this.subscriptions.has(s7) || this.subscriptions.set(s7, { disposer: () => {
      this.subscriptions.delete(s7);
    }, consumerHost: t6 });
    const { disposer: h3 } = this.subscriptions.get(s7);
    s7(this.value, h3);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};

// node_modules/@lit/context/lib/controllers/context-provider.js
var e5 = class extends Event {
  constructor(t6, s7) {
    super("context-provider", { bubbles: true, composed: true }), this.context = t6, this.contextTarget = s7;
  }
};
var i5 = class extends s6 {
  constructor(s7, e7, i6) {
    super(void 0 !== e7.context ? e7.initialValue : i6), this.onContextRequest = (t6) => {
      if (t6.context !== this.context) return;
      const s8 = t6.contextTarget ?? t6.composedPath()[0];
      s8 !== this.host && (t6.stopPropagation(), this.addCallback(t6.callback, s8, t6.subscribe));
    }, this.onProviderRequest = (s8) => {
      if (s8.context !== this.context) return;
      if ((s8.contextTarget ?? s8.composedPath()[0]) === this.host) return;
      const e8 = /* @__PURE__ */ new Set();
      for (const [s9, { consumerHost: i7 }] of this.subscriptions) e8.has(s9) || (e8.add(s9), i7.dispatchEvent(new s4(this.context, i7, s9, true)));
      s8.stopPropagation();
    }, this.host = s7, void 0 !== e7.context ? this.context = e7.context : this.context = e7, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new e5(this.context, this.host));
  }
};

// node_modules/@lit/context/lib/decorators/provide.js
function e6({ context: e7 }) {
  return (n7, i6) => {
    const r6 = /* @__PURE__ */ new WeakMap();
    if ("object" == typeof i6) return { get() {
      return n7.get.call(this);
    }, set(t6) {
      return r6.get(this).setValue(t6), n7.set.call(this, t6);
    }, init(n8) {
      return r6.set(this, new i5(this, { context: e7, initialValue: n8 })), n8;
    } };
    {
      n7.constructor.addInitializer(((n8) => {
        r6.set(n8, new i5(n8, { context: e7 }));
      }));
      const o6 = Object.getOwnPropertyDescriptor(n7, i6);
      let s7;
      if (void 0 === o6) {
        const t6 = /* @__PURE__ */ new WeakMap();
        s7 = { get() {
          return t6.get(this);
        }, set(e8) {
          r6.get(this).setValue(e8), t6.set(this, e8);
        }, configurable: true, enumerable: true };
      } else {
        const t6 = o6.set;
        s7 = { ...o6, set(e8) {
          r6.get(this).setValue(e8), t6?.call(this, e8);
        } };
      }
      return void Object.defineProperty(n7, i6, s7);
    }
  };
}

// node_modules/@lit/context/lib/decorators/consume.js
function c4({ context: c5, subscribe: e7 }) {
  return (o6, n7) => {
    "object" == typeof n7 ? n7.addInitializer((function() {
      new s5(this, { context: c5, callback: (t6) => {
        o6.set.call(this, t6);
      }, subscribe: e7 });
    })) : o6.constructor.addInitializer(((o7) => {
      new s5(o7, { context: c5, callback: (t6) => {
        o7[n7] = t6;
      }, subscribe: e7 });
    }));
  };
}

// src/ui/scrybbleContext.ts
var scrybbleContext = n6("scrybble-common");

// src/SyncJob.ts
var import_typescript_fsm = __toESM(require_stateMachine());

// src/ui/Components/SyncNotice.ts
var import_obsidian6 = require("obsidian");
var SyncProgressIndicator = class extends i4 {
  constructor() {
    super(...arguments);
    this.state = "INIT" /* init */;
    this.filename = "";
  }
  render() {
    return x`<div class="sync-progress">
			<div class="title">Syncing <b>${this.filename}</b></div>
			<div class="progress">
				<div class="progress-line"></div>

				<div class="stage ${this.getStageClass("sync")}">
					<div class="stage-indicator">${this.getStageIcon("sync")}</div>
					<div class="stage-label">${this.getStageLabel("sync")}</div>
				</div>

				<div class="stage ${this.getStageClass("process")}">
					<div class="stage-indicator">${this.getStageIcon("process")}</div>
					<div class="stage-label">${this.getStageLabel("process")}</div>
				</div>

				<div class="stage ${this.getStageClass("download")}">
					<div class="stage-indicator">${this.getStageIcon("download")}</div>
					<div class="stage-label">${this.getStageLabel("download")}</div>
				</div>
			</div>
		</div>`;
  }
  getStageLabel(stage) {
    switch (stage) {
      case "sync":
        if (this.state === "INIT" /* init */) return "Request Sync";
        if (this.state === "SYNC_REQUESTED" /* sync_requested */) return "Requesting Sync";
        if (this.getStageClass("sync") === "stage-completed") return "Requested Sync";
        return "Request Sync";
      case "process":
        if (this.state === "INIT" /* init */ || this.state === "SYNC_REQUESTED" /* sync_requested */)
          return "Process File";
        if (this.state === "PROCESSING" /* processing */ || this.state === "AWAITING_PROCESSING" /* awaiting_processing */)
          return "Processing File";
        if (this.state === "FAILED_TO_PROCESS" /* failed_to_process */)
          return "Failed to Process File";
        if (this.getStageClass("process") === "stage-completed")
          return "Processed File";
        return "Process File";
      case "download":
        if (this.state === "INIT" /* init */ || this.state === "SYNC_REQUESTED" /* sync_requested */ || this.state === "PROCESSING" /* processing */ || this.state === "AWAITING_PROCESSING" /* awaiting_processing */)
          return "Download";
        if (this.state === "READY_TO_DOWNLOAD" /* ready_to_download */)
          return "Ready to Download";
        if (this.state === "DOWNLOADING" /* downloading */)
          return "Downloading";
        if (this.state === "DOWNLOADED" /* downloaded */)
          return "Downloaded";
        if (this.state === "FAILED_TO_DOWNLOAD" /* failed_to_download */)
          return "Failed to download";
        return "Download";
    }
  }
  getStageClass(stage) {
    switch (stage) {
      case "sync":
        if (this.state === "SYNC_REQUESTED" /* sync_requested */) return "stage-waiting";
        if (this.state === "PROCESSING" /* processing */ || this.state === "AWAITING_PROCESSING" /* awaiting_processing */ || this.state === "READY_TO_DOWNLOAD" /* ready_to_download */ || this.state === "DOWNLOADING" /* downloading */ || this.state === "DOWNLOADED" /* downloaded */ || this.state === "FAILED_TO_PROCESS" /* failed_to_process */) return "stage-completed";
        return "";
      case "process":
        if (this.state === "PROCESSING" /* processing */ || this.state === "AWAITING_PROCESSING" /* awaiting_processing */) return "stage-waiting";
        if (this.state === "FAILED_TO_PROCESS" /* failed_to_process */) return "stage-error";
        if (this.state === "READY_TO_DOWNLOAD" /* ready_to_download */ || this.state === "DOWNLOADING" /* downloading */ || this.state === "DOWNLOADED" /* downloaded */) return "stage-completed";
        return "";
      case "download":
        if (this.state === "DOWNLOADING" /* downloading */) return "stage-waiting";
        if (this.state === "FAILED_TO_DOWNLOAD" /* failed_to_download */) return "stage-error";
        if (this.state === "DOWNLOADED" /* downloaded */) return "stage-completed";
        return "";
    }
  }
  getStageIcon(stage) {
    const stageClass = this.getStageClass(stage);
    if (stageClass === "stage-completed") return "\u2713";
    if (stageClass === "stage-error") return "!";
    return "";
  }
  createRenderRoot() {
    return this;
  }
};
__decorateClass([
  n5({ type: String })
], SyncProgressIndicator.prototype, "state", 2);
__decorateClass([
  n5({ type: String })
], SyncProgressIndicator.prototype, "filename", 2);
var SyncProgressNotice = class {
  constructor(filename) {
    this.notice = new import_obsidian6.Notice("", 0);
    this.indicator = new SyncProgressIndicator();
    this.indicator.filename = filename;
    this.indicator.state = "INIT" /* init */;
    this.notice.containerEl.style.whiteSpace = "normal";
    this.notice.containerEl.style.maxWidth = "calc(var(--size-4-18) * 5 + 2 * var(--size-4-3))";
    B(this.indicator, this.notice.containerEl);
  }
  updateState(newState) {
    this.indicator.state = newState;
    if (newState === "DOWNLOADED" /* downloaded */) {
      setTimeout(() => {
        this.notice.hide();
      }, 2e3);
    }
    if (newState === "FAILED_TO_PROCESS" /* failed_to_process */ || newState === "FAILED_TO_DOWNLOAD" /* failed_to_download */) {
      setTimeout(() => {
        this.notice.hide();
      }, 5e3);
    }
  }
};

// src/SyncJob.ts
var SyncJob = class extends import_typescript_fsm.StateMachine {
  constructor(key = 0, init = "INIT" /* init */, onStateChange, filename) {
    super(init, [], console);
    this.onStateChange = onStateChange;
    this.filename = filename;
    const notice = new SyncProgressNotice(filename);
    this.onStateChange(this.filename, "INIT" /* init */, this);
    notice.updateState(init);
    const transitions = [
      (0, import_typescript_fsm.t)("INIT" /* init */, "SYNC_REQUEST_SENT" /* syncRequestSent */, "SYNC_REQUESTED" /* sync_requested */, () => {
        this.onStateChange(this.filename, "SYNC_REQUESTED" /* sync_requested */, this);
        notice.updateState("SYNC_REQUESTED" /* sync_requested */);
      }),
      (0, import_typescript_fsm.t)("INIT" /* init */, "READY" /* ready */, "READY_TO_DOWNLOAD" /* ready_to_download */, () => {
        this.onStateChange(this.filename, "READY_TO_DOWNLOAD" /* ready_to_download */, this);
        notice.updateState("READY_TO_DOWNLOAD" /* ready_to_download */);
      }),
      (0, import_typescript_fsm.t)("SYNC_REQUESTED" /* sync_requested */, "SYNC_REQUEST_CONFIRMED" /* syncRequestConfirmed */, "PROCESSING" /* processing */, () => {
        this.onStateChange(this.filename, "PROCESSING" /* processing */, this);
        notice.updateState("PROCESSING" /* processing */);
      }),
      (0, import_typescript_fsm.t)("PROCESSING" /* processing */, "CHECKING_PROCESSING_STATE" /* sentProcessingCheckRequest */, "AWAITING_PROCESSING" /* awaiting_processing */, () => {
        this.onStateChange(this.filename, "AWAITING_PROCESSING" /* awaiting_processing */, this);
        notice.updateState("AWAITING_PROCESSING" /* awaiting_processing */);
      }),
      (0, import_typescript_fsm.t)("AWAITING_PROCESSING" /* awaiting_processing */, "READY" /* ready */, "READY_TO_DOWNLOAD" /* ready_to_download */, () => {
        this.onStateChange(this.filename, "READY_TO_DOWNLOAD" /* ready_to_download */, this);
        notice.updateState("READY_TO_DOWNLOAD" /* ready_to_download */);
      }),
      (0, import_typescript_fsm.t)("AWAITING_PROCESSING" /* awaiting_processing */, "STILL_PROCESSING" /* stillProcessing */, "PROCESSING" /* processing */, () => {
        this.onStateChange(this.filename, "PROCESSING" /* processing */, this);
        notice.updateState("PROCESSING" /* processing */);
      }),
      (0, import_typescript_fsm.t)("AWAITING_PROCESSING" /* awaiting_processing */, "FAILED_TO_PROCESS" /* failedToProcess */, "FAILED_TO_PROCESS" /* failed_to_process */, () => {
        this.onStateChange(this.filename, "FAILED_TO_PROCESS" /* failed_to_process */, this);
        notice.updateState("FAILED_TO_PROCESS" /* failed_to_process */);
      }),
      (0, import_typescript_fsm.t)("PROCESSING" /* processing */, "READY" /* ready */, "READY_TO_DOWNLOAD" /* ready_to_download */, () => {
        this.onStateChange(this.filename, "READY_TO_DOWNLOAD" /* ready_to_download */, this);
        notice.updateState("READY_TO_DOWNLOAD" /* ready_to_download */);
      }),
      (0, import_typescript_fsm.t)("PROCESSING" /* processing */, "FAILED_TO_PROCESS" /* failedToProcess */, "FAILED_TO_PROCESS" /* failed_to_process */, () => {
        this.onStateChange(this.filename, "FAILED_TO_PROCESS" /* failed_to_process */, this);
        notice.updateState("FAILED_TO_PROCESS" /* failed_to_process */);
      }),
      (0, import_typescript_fsm.t)("READY_TO_DOWNLOAD" /* ready_to_download */, "DOWNLOAD_REQUEST_SENT" /* downloadRequestSent */, "DOWNLOADING" /* downloading */, () => {
        this.onStateChange(this.filename, "DOWNLOADING" /* downloading */, this);
        notice.updateState("DOWNLOADING" /* downloading */);
      }),
      (0, import_typescript_fsm.t)("DOWNLOADING" /* downloading */, "DOWNLOAD_FAILED" /* downloadFailed */, "DOWNLOADED" /* downloaded */, () => {
        this.onStateChange(this.filename, "FAILED_TO_DOWNLOAD" /* failed_to_download */, this);
        notice.updateState("FAILED_TO_DOWNLOAD" /* failed_to_download */);
      }),
      (0, import_typescript_fsm.t)("DOWNLOADING" /* downloading */, "DOWNLOADED" /* downloaded */, "DOWNLOADED" /* downloaded */, () => {
        this.onStateChange(this.filename, "DOWNLOADED" /* downloaded */, this);
        notice.updateState("DOWNLOADED" /* downloaded */);
      })
    ];
    this.addTransitions(transitions);
  }
  async readyToDownload(download_url, sync_id) {
    this.download_url = download_url;
    this.sync_id = sync_id;
    await this.dispatch("READY" /* ready */);
  }
  async downloaded() {
    await this.dispatch("DOWNLOADED" /* downloaded */);
  }
  async syncRequestConfirmed(sync_id) {
    await this.dispatch("SYNC_REQUEST_CONFIRMED" /* syncRequestConfirmed */);
    this.sync_id = sync_id;
  }
  async sentProcessingRequest() {
    await this.dispatch("CHECKING_PROCESSING_STATE" /* sentProcessingCheckRequest */);
  }
  async fileStillProcessing() {
    await this.dispatch("STILL_PROCESSING" /* stillProcessing */);
  }
  async syncRequestSent() {
    await this.dispatch("SYNC_REQUEST_SENT" /* syncRequestSent */);
  }
  async startDownload() {
    await this.dispatch("DOWNLOAD_REQUEST_SENT" /* downloadRequestSent */);
  }
  async processingFailed() {
    await this.dispatch("FAILED_TO_PROCESS" /* failedToProcess */);
  }
  async downloadingFailed() {
    await this.dispatch("DOWNLOAD_FAILED" /* downloadFailed */);
  }
};

// src/ui/Components/RmFile.ts
var import_path = __toESM(require_path_browserify());
var RmFile = class extends i4 {
  constructor() {
    super();
    this.currentlySyncing = false;
    this.syncOverride = void 0;
  }
  get sync() {
    if (this.syncOverride != null) {
      return this.syncOverride;
    }
    return this.file.sync;
  }
  connectedCallback() {
    super.connectedCallback();
    this.scrybble.sync.subscribeToSyncStateChangesForFile(this.file.path, (newState, job) => {
      this.currentlySyncing = !(newState === "DOWNLOADED" /* downloaded */ || newState === "FAILED_TO_PROCESS" /* failed_to_process */);
      if (newState === "DOWNLOADED" /* downloaded */) {
        this.syncOverride = {
          error: false,
          completed: true,
          created_at: "Just now",
          id: job.sync_id
        };
      } else if (newState === "FAILED_TO_PROCESS" /* failed_to_process */) {
        this.syncOverride = {
          error: true,
          completed: false,
          created_at: "Just now",
          id: job.sync_id
        };
      }
      this.requestUpdate();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.scrybble.sync.unsubscribeToSyncStateChangesForFile(this.file.path);
  }
  render() {
    let syncState;
    if (this.currentlySyncing) {
      syncState = "file-clock";
    } else if (this.sync?.error) {
      syncState = "file-x-2";
    } else if (this.sync?.completed) {
      syncState = "file-check-2";
    } else if (this.sync != null && !this.sync?.error && !this.sync?.completed) {
      syncState = "file-clock";
    } else {
      syncState = "file";
    }
    const { pdf, md } = this.findFile();
    return x`
			<div class="tree-item" @click="${this._handleClick}" aria-label="${`${this.file.name}
			
Click to download file to your vault`}">
				<div class="tree-item-self rm-file is-clickable">
					<span class="tree-item-icon">${this.currentlySyncing ? this.renderSpinner() : (0, import_obsidian7.getIcon)(syncState)}</span>
					<span class="filename">${this.file.name}</span>
				</div>
			</div>
			<div class="tree-item">
				<div class="tree-item-self additional">
					<span class="when">${this.sync ? this.sync.created_at : "Not synced yet"}</span>
					<span class="file-links">
						${this.sync ? x`
							<a class="feedback ${this.currentlySyncing ? "disabled" : ""}" @click="${this.openFeedbackDialog.bind(this)}">feedback</a>
							<span class="vertical-separator"></span>
							<span class="pill pdf ${pdf ? "available" : "unavailable"}"
								  @click="${this.clickPdf.bind(this)}">PDF</span>
							<span class="pill md ${md ? "available" : "unavailable"}"
								  @click="${this.clickMd.bind(this)}">MD</span>
						` : E}
					</span>
				</div>
			</div>
		`;
  }
  createRenderRoot() {
    return this;
  }
  openFeedbackDialog() {
    if (this.currentlySyncing) {
      new import_obsidian7.Notice("Not available during syncing, please wait until syncing is done.");
      return;
    }
    this.scrybble.openFeedbackDialog(
      this.file,
      async (details) => {
        await this.scrybble.api.fetchGiveFeedback(details);
      }
    );
  }
  clickMd(e7) {
    const { md, mdPath } = this.findFile();
    if (md) {
      const fileNavigator = this.scrybble.fileNavigator;
      fileNavigator.showContextMenu(e7, [
        {
          title: "Open Markdown file in new tab",
          icon: "file-plus",
          onClick: () => fileNavigator.openInNewTab(mdPath)
        },
        {
          title: "Open Markdown file in vertical split view",
          icon: "separator-vertical",
          onClick: () => fileNavigator.openInVerticalSplit(mdPath)
        },
        {
          title: "Open Markdown file in horizontal split view",
          icon: "separator-horizontal",
          onClick: () => fileNavigator.openInHorizontalSplit(mdPath)
        }
      ]);
    }
  }
  clickPdf(e7) {
    const { pdf, pdfPath } = this.findFile();
    if (pdf) {
      const fileNavigator = this.scrybble.fileNavigator;
      fileNavigator.showContextMenu(e7, [
        {
          title: "Open PDF file in new tab",
          icon: "file-plus",
          onClick: () => fileNavigator.openInNewTab(pdfPath)
        },
        {
          title: "Open PDF file in vertical split view",
          icon: "separator-vertical",
          onClick: () => fileNavigator.openInVerticalSplit(pdfPath)
        },
        {
          title: "Open PDF file in horizontal split view",
          icon: "separator-horizontal",
          onClick: () => fileNavigator.openInHorizontalSplit(pdfPath)
        }
      ]);
    }
  }
  _handleClick() {
    this.dispatchEvent(new CustomEvent("rm-click", {
      detail: { name: this.file.name, path: this.file.path, type: "f" },
      bubbles: true,
      composed: true
    }));
  }
  findFile() {
    const sanitizedName = sanitizeFilename(this.file.path.substring(1, this.file.path.length), true);
    let rootFolder = this.scrybble.settings.sync_folder;
    if (import_path.default.isAbsolute(rootFolder)) {
      rootFolder = rootFolder.replace(/^\//, "");
    }
    const pdfPath = import_path.default.join(rootFolder, `${sanitizedName}.pdf`);
    const mdPath = import_path.default.join(rootFolder, `${sanitizedName}.md`);
    const pdf = this.scrybble.fileNavigator.getFileByPath(pdfPath);
    const md = this.scrybble.fileNavigator.getFileByPath(mdPath);
    return {
      pdfPath,
      mdPath,
      pdf,
      md
    };
  }
  renderSpinner() {
    return x`${(0, import_obsidian7.getIcon)("loader-circle")}`;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ type: Object, attribute: false })
], RmFile.prototype, "scrybble", 2);
__decorateClass([
  n5({ type: Object })
], RmFile.prototype, "file", 2);
__decorateClass([
  r5()
], RmFile.prototype, "currentlySyncing", 2);
__decorateClass([
  r5()
], RmFile.prototype, "syncOverride", 2);

// src/ui/Components/RmFileTree.ts
var RmFileTree = class extends i4 {
  render() {
    return x`
			<div class="scrybble-filetree">
				<div class="tree-item-self">
					<div class="tree-item-inner text-normal">Current directory is <b>${this.tree.cwd}</b></div>
				</div>

				<div class="files">
					${this.tree.items.map((fileOrDirectory) => {
      if (fileOrDirectory.type === "d") {
        return x`<rm-dir .directory="${fileOrDirectory}" />`;
      } else if (fileOrDirectory.type === "f") {
        return x` <rm-file .file="${fileOrDirectory}" />`;
      }
    })}
				</div>
			</div>`;
  }
  createRenderRoot() {
    return this;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ type: Object, attribute: false })
], RmFileTree.prototype, "scrybble", 2);
__decorateClass([
  n5({ type: Object })
], RmFileTree.prototype, "tree", 2);
__decorateClass([
  n5({ type: String })
], RmFileTree.prototype, "cwd", 2);

// src/errorHandling/logging.ts
var p3 = __toESM(require_browser());
var storageKey = "scrybble-logs";
var maxEntries = 200;
function retrieveScrybbleLogs() {
  return JSON.parse(localStorage.getItem(storageKey) ?? "[]");
}
function writeToLocalstorage(obj) {
  delete obj["hostname"];
  delete obj["pid"];
  delete obj["time"];
  try {
    const existingLogs = JSON.parse(localStorage.getItem(storageKey) || "[]");
    const logEntry = {
      ...obj,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    existingLogs.push(logEntry);
    if (existingLogs.length > maxEntries) {
      existingLogs.splice(0, existingLogs.length - maxEntries);
    }
    localStorage.setItem(storageKey, JSON.stringify(existingLogs));
  } catch (error) {
    console.error("Failed to write to localStorage transport:", error);
    console.log("Original log:", obj);
  }
}
var pino = p3.default({
  browser: {
    write: writeToLocalstorage,
    serialize: true
  }
});

// src/errorHandling/Errors.ts
function formatError(e7) {
  if (e7 && "status" in e7 && e7.status) {
    return x`: response status - ${e7.status}`;
  }
  return x``;
}
var SUPPORT_EMAIL = "mail@scrybble.ink";
var PERSISTENT_PROBLEM_MESSAGE = `If the problem persists, contact ${SUPPORT_EMAIL} for support`;
var errors = {
  "FILE_DOWNLOAD_ERROR": (e7) => ({
    title: x`Unable to download the file`,
    message: x`..`,
    helpAction: x`...`
  }),
  "ZIP_EXTRACT_ERROR": (e7) => ({
    title: x`Unable to extract the downloaded files`,
    message: x`Your file is likely corrupted.`,
    helpAction: x`Contact support for further guidance, ${SUPPORT_EMAIL}`,
    details: e7
  }),
  "UNABLE_TO_CREATE_FOLDER": (e7) => ({
    title: x`Unable to create folder`,
    message: x`Does your folder contain unsupported characters?`,
    helpAction: x`Contact support for further guidance, ${SUPPORT_EMAIL}`
  }),
  "TREE_LOADING_ERROR": (e7) => ({
    title: x`File loading error`,
    message: x`There's a problem loading your files${formatError(e7)}`,
    helpAction: x`Please try refreshing in a minute or so. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "SYNC_HISTORY_ERROR": (e7) => ({
    title: x`Sync history error`,
    message: x`There was a problem loading your sync history${formatError(e7)}`,
    helpAction: x`Please try refreshing in a minute or so. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "AUTHENTICATION_CHECK_ERROR": (e7) => ({
    title: x`Authentication check failed`,
    message: x`We couldn't verify your login status${formatError(e7)}`,
    helpAction: x`Please check your internet connection and try again. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "OAUTH_INITIATION_ERROR": (e7) => ({
    title: x`Login failed to start`,
    message: x`We couldn't start the login process${formatError(e7)}`,
    helpAction: x`Please check your internet connection and try again. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "OAUTH_COMPLETION_ERROR": (e7) => ({
    title: x`Login completion failed`,
    message: x`Login was successful but we couldn't fetch your account information${formatError(e7)}`,
    helpAction: x`Please try refreshing the page. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "USER_INFO_FETCH_ERROR": (e7) => ({
    title: x`Account information unavailable`,
    message: x`We couldn't load your account information${formatError(e7)}`,
    helpAction: x`Please try refreshing the page or logging out and back in. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "DEVICE_AUTH_INITIATION_ERROR": (e7) => ({
    title: x`Device authorization failed`,
    message: x`We couldn't start the device authorization process${formatError(e7)}`,
    helpAction: x`Please cancel and try again. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "REQUEST_FILE_SYNC_ERROR": (e7) => ({
    title: x`Failed to request sync for a file`,
    message: x`There is likely a problem with the server.`,
    helpAction: x`Please try again in a minute or so. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "GENERAL_ERROR": (e7) => ({
    title: x`Something went wrong`,
    message: x`An unexpected error occurred${formatError(e7)}`,
    helpAction: x`Please try again. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  }),
  "SERVER_CONNECTION_ERROR": (e7) => ({
    title: x`Connection error`,
    message: x`Could not connect to the Scrybble servers${formatError(e7)}`,
    helpAction: x`Please try again later. ${PERSISTENT_PROBLEM_MESSAGE}`,
    details: e7
  })
};
var Errors = class {
  static handle(error_name, e7) {
    if (e7) {
      pino.error({ err: e7 }, `Scrybble ${error_name} occurred.`);
    } else {
      e7 = new Error("No error specified by caller");
      pino.error(`Scrybble ${error_name} occurred.`);
    }
    if (e7 && "message" in e7 && e7.message.includes("ERR_CONNECTION_REFUSED")) {
      return errors["SERVER_CONNECTION_ERROR"](e7);
    }
    return errors[error_name](e7);
  }
};

// src/ui/Pages/ScrybbleFileTree.ts
var import_obsidian8 = require("obsidian");
var ScrybbleFileTreeComponent = class extends i4 {
  constructor() {
    super(...arguments);
    this.cwd = "/";
    this.loading = true;
    this.error = null;
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.loadTree();
  }
  async refresh() {
    await this.loadTree();
    this.requestUpdate();
  }
  async handleClickFileOrFolder({ detail: { path: path3, type } }) {
    if (type === "f") {
      try {
        this.scrybble.sync.requestSync(path3);
      } catch (e7) {
        Errors.handle("REQUEST_FILE_SYNC_ERROR", e7);
      }
    } else if (type === "d") {
      this.cwd = path3;
      await this.loadTree();
    }
  }
  async loadTree() {
    try {
      this.loading = true;
      this.requestUpdate();
      this.tree = await this.scrybble.api.fetchFileTree(this.cwd);
      this.error = null;
    } catch (e7) {
      this.error = Errors.handle("TREE_LOADING_ERROR", e7);
    } finally {
      this.loading = false;
      this.requestUpdate();
    }
  }
  render() {
    const error = this.error ? x`
			<div class="scrybble-error">
				<h3>${this.error.title}</h3>
				<p>${this.error.message}</p>
				<p>${this.error.helpAction}</p>
			</div>` : E;
    const heading = x`
			<div class="scrybble-header">
				<h3>reMarkable file tree</h3>
				<button
					?disabled="${this.loading}"
					@click="${this.refresh.bind(this)}"
					class="mod-cta scrybble-refresh-button"
				>
					<span class="tree-item-icon scrybble-icon">${(0, import_obsidian8.getIcon)("refresh-ccw")}</span>
					${this.loading ? "Loading..." : "Refresh"}
				</button>
			</div>`;
    const tree = !this.error && this.tree ? x`
			<rm-tree .tree="${this.tree}" @rm-click="${this.handleClickFileOrFolder.bind(this)}"></rm-tree>` : E;
    return x`
			<div class="inner-container">
				${heading}
				${error}
				${tree}
			</div>
		`;
  }
  createRenderRoot() {
    return this;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ type: Object, attribute: false })
], ScrybbleFileTreeComponent.prototype, "scrybble", 2);
__decorateClass([
  r5()
], ScrybbleFileTreeComponent.prototype, "tree", 2);
__decorateClass([
  r5()
], ScrybbleFileTreeComponent.prototype, "cwd", 2);
__decorateClass([
  r5()
], ScrybbleFileTreeComponent.prototype, "loading", 2);
__decorateClass([
  r5()
], ScrybbleFileTreeComponent.prototype, "error", 2);

// src/ui/Components/ErrorComponent.ts
var ErrorComponent = class extends i4 {
  constructor() {
    super(...arguments);
    this.actions = [];
  }
  render() {
    if (this.error) {
      const errorActions = this.actions.length ? x`<div class="error-actions">${this.actions}</div>` : E;
      return x`
			<div class="error-container">
				<div class="error-content">
					<h2 class="error-title">${this.error.title}</h2>
					<p class="error-message">${this.error.message}</p>
					<p class="error-help-action">${this.error.helpAction}</p>
				</div>
				${errorActions}
			</div>
		`;
    }
  }
  createRenderRoot() {
    return this;
  }
};
__decorateClass([
  n5({ type: Object })
], ErrorComponent.prototype, "error", 2);
__decorateClass([
  n5({ type: Array })
], ErrorComponent.prototype, "actions", 2);

// src/ui/Pages/ScrybbleUI.ts
var import_obsidian9 = require("obsidian");

// src/Authentication.ts
var import_typescript_fsm2 = __toESM(require_stateMachine());
function isDeviceFlowError(response) {
  return response && typeof response === "object" && "error" in response;
}
function getDeviceTokenErrorResponseType(response) {
  if (isDeviceFlowError(response)) {
    return response.error;
  }
  return null;
}
function isSuccessResponse(deviceTokenResponse) {
  return "access_token" in deviceTokenResponse;
}
var Authentication = class extends import_typescript_fsm2.StateMachine {
  constructor(settings, api) {
    super("INIT" /* INIT */, []);
    this.settings = settings;
    this.api = api;
    this.user = null;
    this.deviceAuth = null;
    this.listeners = [];
    this.pollingTimer = null;
    const transitions = [
      (0, import_typescript_fsm2.t)("INIT" /* INIT */, "LOGIN_REQUESTED" /* LOGIN_REQUESTED */, "REQUESTING_DEVICE_CODE" /* REQUESTING_DEVICE_CODE */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("INIT" /* INIT */, "TOKEN_FOUND_ON_STARTUP" /* TOKEN_FOUND_ON_STARTUP */, "FETCHING_USER" /* FETCHING_USER */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("INIT" /* INIT */, "NO_TOKEN_FOUND_ON_STARTUP" /* NO_TOKEN_FOUND_ON_STARTUP */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("REQUESTING_DEVICE_CODE" /* REQUESTING_DEVICE_CODE */, "DEVICE_CODE_RECEIVED" /* DEVICE_CODE_RECEIVED */, "WAITING_FOR_USER_AUTHORIZATION" /* WAITING_FOR_USER_AUTHORIZATION */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("REQUESTING_DEVICE_CODE" /* REQUESTING_DEVICE_CODE */, "DEVICE_CODE_REQUEST_FAILED" /* DEVICE_CODE_REQUEST_FAILED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("WAITING_FOR_USER_AUTHORIZATION" /* WAITING_FOR_USER_AUTHORIZATION */, "POLLING_STARTED" /* POLLING_STARTED */, "POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("WAITING_FOR_USER_AUTHORIZATION" /* WAITING_FOR_USER_AUTHORIZATION */, "DEVICE_FLOW_CANCELED" /* DEVICE_FLOW_CANCELED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */, "ACCESS_TOKEN_RECEIVED" /* ACCESS_TOKEN_RECEIVED */, "FETCHING_USER" /* FETCHING_USER */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */, "AUTHORIZATION_EXPIRED" /* AUTHORIZATION_EXPIRED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */, "AUTHORIZATION_DENIED" /* AUTHORIZATION_DENIED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */, "DEVICE_FLOW_CANCELED" /* DEVICE_FLOW_CANCELED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("FETCHING_USER" /* FETCHING_USER */, "USER_FETCHED" /* USER_FETCHED */, "AUTHENTICATED" /* AUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("FETCHING_USER" /* FETCHING_USER */, "USER_FETCH_FAILED" /* USER_FETCH_FAILED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("AUTHENTICATED" /* AUTHENTICATED */, "LOGOUT_REQUESTED" /* LOGOUT_REQUESTED */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("REFRESHING_TOKEN" /* REFRESHING_TOKEN */, "REFRESH_SUCCESS" /* REFRESH_SUCCESS */, "FETCHING_USER" /* FETCHING_USER */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("REFRESHING_TOKEN" /* REFRESHING_TOKEN */, "REFRESH_FAILURE" /* REFRESH_FAILURE */, "UNAUTHENTICATED" /* UNAUTHENTICATED */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("UNAUTHENTICATED" /* UNAUTHENTICATED */, "LOGIN_REQUESTED" /* LOGIN_REQUESTED */, "REQUESTING_DEVICE_CODE" /* REQUESTING_DEVICE_CODE */, this.broadcastStateChange.bind(this)),
      (0, import_typescript_fsm2.t)("UNAUTHENTICATED" /* UNAUTHENTICATED */, "ACCESS_TOKEN_EXPIRED" /* ACCESS_TOKEN_EXPIRED */, "REFRESHING_TOKEN" /* REFRESHING_TOKEN */, this.broadcastStateChange.bind(this))
    ];
    this.addTransitions(transitions);
  }
  broadcastStateChange() {
    for (const listener of this.listeners) {
      listener(this.getState());
    }
  }
  addStateChangeListener(listener) {
    this.listeners.push(listener);
  }
  async initializeAuth() {
    if (this.settings.access_token) {
      await this.dispatch("TOKEN_FOUND_ON_STARTUP" /* TOKEN_FOUND_ON_STARTUP */);
      await this.fetchAndSetUser();
    } else {
      await this.dispatch("NO_TOKEN_FOUND_ON_STARTUP" /* NO_TOKEN_FOUND_ON_STARTUP */);
    }
  }
  async initiateDeviceFlow() {
    await this.dispatch("LOGIN_REQUESTED" /* LOGIN_REQUESTED */);
    try {
      this.deviceAuth = await this.api.fetchDeviceCode();
      await this.dispatch("DEVICE_CODE_RECEIVED" /* DEVICE_CODE_RECEIVED */);
      setTimeout(() => this.startPolling(), 1e3);
    } catch (error) {
      pino.error(error, "Failed to request device code");
      await this.dispatch("DEVICE_CODE_REQUEST_FAILED" /* DEVICE_CODE_REQUEST_FAILED */);
      throw error;
    }
  }
  async cancelDeviceFlow() {
    this.stopPolling();
    this.deviceAuth = null;
    await this.dispatch("DEVICE_FLOW_CANCELED" /* DEVICE_FLOW_CANCELED */);
  }
  async copyUserCodeToClipboard() {
    if (!this.deviceAuth?.user_code) {
      return false;
    }
    try {
      await navigator.clipboard.writeText(this.deviceAuth.user_code);
      return true;
    } catch (error) {
      pino.warn(error);
      return false;
    }
  }
  openVerificationUrl() {
    if (!this.deviceAuth?.verification_uri) {
      pino.warn("No verification URI available");
      return;
    }
    window.open(this.deviceAuth.verification_uri, "_blank");
  }
  async refreshAccessToken() {
    await this.dispatch("ACCESS_TOKEN_EXPIRED" /* ACCESS_TOKEN_EXPIRED */);
    if (!this.settings.refresh_token) {
      await this.dispatch("REFRESH_FAILURE" /* REFRESH_FAILURE */);
      throw new Error("No refresh token available");
    }
    try {
      const response = await this.api.fetchRefreshOAuthAccessToken();
      this.settings.access_token = response.access_token;
      this.settings.refresh_token = response.refresh_token;
      await this.settings.save();
      await this.dispatch("REFRESH_SUCCESS" /* REFRESH_SUCCESS */);
      pino.info("Successfully refreshed OAuth token");
      return { access_token: response.access_token, refresh_token: response.refresh_token };
    } catch (e7) {
      await this.dispatch("REFRESH_FAILURE" /* REFRESH_FAILURE */);
      this.settings.access_token = void 0;
      this.settings.refresh_token = void 0;
      await this.settings.save();
      throw e7;
    }
  }
  async refreshToken(error) {
    if ("status" in error && error.status === 401 && this.settings.refresh_token) {
      pino.warn("Got a 401, refreshing");
      try {
        await this.refreshAccessToken();
        await this.fetchAndSetUser(false);
      } catch (refreshError) {
        pino.error(error, "You were unexpectedly logged out, please try to log back in again.");
        this.settings.refresh_token = void 0;
        this.settings.access_token = void 0;
        await this.settings.save();
        this.user = null;
        await this.dispatch("LOGOUT_REQUESTED" /* LOGOUT_REQUESTED */);
        throw error;
      }
    } else {
      pino.error("Unexpected server error");
      throw error;
    }
  }
  async logout() {
    this.stopPolling();
    this.deviceAuth = null;
    this.settings.access_token = void 0;
    this.settings.refresh_token = void 0;
    this.user = null;
    await this.settings.save();
    await this.dispatch("LOGOUT_REQUESTED" /* LOGOUT_REQUESTED */);
  }
  isAuthenticated() {
    return this.getState() === "AUTHENTICATED" /* AUTHENTICATED */;
  }
  async fetchAndSetUser(attemptRefreshOnFailure = true) {
    try {
      this.user = await this.api.fetchGetUser();
      await this.dispatch("USER_FETCHED" /* USER_FETCHED */);
    } catch (error) {
      pino.error(error, "Failed to fetch user data");
      await this.dispatch("USER_FETCH_FAILED" /* USER_FETCH_FAILED */);
      if (attemptRefreshOnFailure) {
        await this.refreshToken(error);
      }
    }
  }
  async startPolling() {
    if (!this.deviceAuth) {
      pino.error("Cannot start polling: no device auth data");
      return;
    }
    await this.dispatch("POLLING_STARTED" /* POLLING_STARTED */);
    const startTime = Date.now();
    const expirationTime = startTime + this.deviceAuth.expires_in * 1e3;
    let currentInterval = this.deviceAuth.interval;
    const poll = async () => {
      if (Date.now() >= expirationTime) {
        pino.warn("Device authorization expired");
        this.stopPolling();
        await this.dispatch("AUTHORIZATION_EXPIRED" /* AUTHORIZATION_EXPIRED */);
        return;
      }
      if (this.getState() !== "POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */) {
        this.stopPolling();
        return;
      }
      try {
        const deviceTokenResponse = await this.api.fetchPollForDeviceToken(this.deviceAuth.device_code);
        if (isSuccessResponse(deviceTokenResponse)) {
          this.stopPolling();
          this.deviceAuth = null;
          this.settings.access_token = deviceTokenResponse.access_token;
          this.settings.refresh_token = deviceTokenResponse.refresh_token;
          await this.settings.save();
          await this.dispatch("ACCESS_TOKEN_RECEIVED" /* ACCESS_TOKEN_RECEIVED */);
          await this.fetchAndSetUser();
          return;
        }
        switch (getDeviceTokenErrorResponseType(deviceTokenResponse)) {
          case "authorization_pending":
            this.scheduleNextPoll(currentInterval, poll);
            break;
          case "slow_down":
            currentInterval += 5;
            this.scheduleNextPoll(currentInterval, poll);
            break;
          case "access_denied":
            pino.info("User denied device authorization");
            this.stopPolling();
            this.deviceAuth = null;
            await this.dispatch("AUTHORIZATION_DENIED" /* AUTHORIZATION_DENIED */);
            break;
          case "expired_token":
            pino.warn("Device code expired");
            this.stopPolling();
            this.deviceAuth = null;
            await this.dispatch("AUTHORIZATION_EXPIRED" /* AUTHORIZATION_EXPIRED */);
            break;
          default:
            pino.error(deviceTokenResponse, "Unexpected error during device polling");
            this.stopPolling();
            this.deviceAuth = null;
            await this.dispatch("AUTHORIZATION_DENIED" /* AUTHORIZATION_DENIED */);
            break;
        }
      } catch (error) {
        pino.error(error, "Failed to poll for device token");
      }
    };
    this.scheduleNextPoll(currentInterval, poll);
  }
  scheduleNextPoll(interval, pollFunction) {
    this.pollingTimer = window.setTimeout(pollFunction, interval * 1e3);
  }
  stopPolling() {
    if (this.pollingTimer) {
      clearTimeout(this.pollingTimer);
      this.pollingTimer = null;
    }
  }
};

// src/ui/Pages/ScrybbleUI.ts
var ScrybbleUI = class extends i4 {
  constructor() {
    super(...arguments);
    this.currentView = "file_tree" /* FILE_TREE */;
    this.error = null;
  }
  async initialize() {
    this.scrybble.authentication.addStateChangeListener((state) => {
      if (state === "AUTHENTICATED" /* AUTHENTICATED */) {
        if (this.scrybble.authentication.user?.onboarding_state !== "ready") {
          this.currentView = "onboarding" /* ONBOARDING */;
        }
        this.requestUpdate();
      } else if (state === "UNAUTHENTICATED" /* UNAUTHENTICATED */) {
        this.requestUpdate();
      }
    });
    if (!this.scrybble.settings.access_token) {
      this.currentView = "login" /* ACCOUNT */;
      return;
    }
  }
  shouldDisableNavButton() {
    if (this.currentView === "onboarding" /* ONBOARDING */) {
      return this.scrybble.authentication.user.onboarding_state !== "ready";
    }
    return !this.scrybble.authentication.user;
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.initialize();
  }
  async switchView(view) {
    if (this.currentView !== view) {
      this.currentView = view;
      this.onViewSwitch(view);
    }
  }
  async handleErrorRefresh() {
    this.error = null;
    await this.initialize();
    await this.onErrorRefresh();
  }
  render() {
    const { error } = this;
    const errorTemplate = error ? x`
            <error-view .error="${error}" .actions="${[x`
                <button class="retry" @click="${() => this.handleErrorRefresh()}">Refresh</button>`]}"/>` : E;
    return x`
			${this.renderNavigation()}
			<div class="scrybble-container">
				${this.currentView === "support" /* SUPPORT */ ? E : errorTemplate}
				${error && this.currentView !== "support" /* SUPPORT */ ? E : this.renderCurrentView()}
			</div>
        `;
  }
  renderNavigation() {
    const { currentView } = this;
    return x`
			<div class="nav-header">
				<div class="nav-buttons-container">
					<button style="display: flex; flex-direction: column"
							?disabled="${this.shouldDisableNavButton()}"
							class="clickable-icon nav-action-button ${currentView === "file_tree" /* FILE_TREE */ ? "is-active" : ""}"
							aria-label="${this.shouldDisableNavButton() ? "Complete setup first" : "File tree"}"
							@click="${() => this.switchView("file_tree" /* FILE_TREE */)}">
						<span>${(0, import_obsidian9.getIcon)("folder")}</span>
						<span>Files</span>
					</button>
					<button style="display: flex; flex-direction: column"
							class="clickable-icon nav-action-button ${currentView === "support" /* SUPPORT */ ? "is-active" : ""}"
							aria-label="Support"
							@click="${() => this.switchView("support" /* SUPPORT */)}">
						<span>${(0, import_obsidian9.getIcon)("badge-help")}</span>
						<span>Support</span>
					</button>
					<button style="display: flex; flex-direction: column"
							class="clickable-icon nav-action-button ${currentView === "login" /* ACCOUNT */ ? "is-active" : ""}"
							aria-label="Account"
							@click="${() => this.switchView("login" /* ACCOUNT */)}">
						<span>${(0, import_obsidian9.getIcon)("user")}</span>
						<span>Account</span>
					</button>
				</div>
			</div>
		`;
  }
  renderCurrentView() {
    const { currentView } = this;
    switch (currentView) {
      case "file_tree" /* FILE_TREE */:
        return x`<scrybble-file-tree/>`;
      case "support" /* SUPPORT */:
        return x`<scrybble-support/>`;
      case "login" /* ACCOUNT */:
        return x`<scrybble-account/>`;
      case "onboarding" /* ONBOARDING */:
        return x`<scrybble-onboarding 
					.onboardingReady="${this.requestUpdate.bind(this)}"
				/>`;
      default:
        return E;
    }
  }
  createRenderRoot() {
    return this;
  }
};
__decorateClass([
  r5()
], ScrybbleUI.prototype, "currentView", 2);
__decorateClass([
  r5()
], ScrybbleUI.prototype, "error", 2);
__decorateClass([
  n5({ type: Object, attribute: false }),
  e6({ context: scrybbleContext })
], ScrybbleUI.prototype, "scrybble", 2);
__decorateClass([
  n5({ type: Function, attribute: false })
], ScrybbleUI.prototype, "onViewSwitch", 2);
__decorateClass([
  n5({ type: Function, attribute: false })
], ScrybbleUI.prototype, "onErrorRefresh", 2);

// src/ui/Pages/SupportPage.ts
var import_obsidian10 = require("obsidian");
var SupportPage = class extends i4 {
  render() {
    return x`
			<div class="inner-container">
				<div class="scrybble-header">
					<h3>Scrybble Support</h3>
				</div>

				<!-- Contact Section -->
				<div class="contact-section">
					<h4>Get Help</h4>
					<p><strong>${(0, import_obsidian10.getIcon)("mail")} Email</strong> <a
						href="mailto:mail@scrybble.ink">mail@scrybble.ink</a></p>
					<p><strong>${(0, import_obsidian10.getIcon)("message-circle")} Discord</strong> <a
						href="https://discord.gg/zPrAUzNuSN" target="_blank">Join our community</a> - other users can help too!</p>
				</div>

				<div class="section">
					<h4>Bug Report Template</h4>
					<p>Copy this template when sending a bug report:</p>
					<textarea
						class="template-textarea"
						readonly
						.value=${this.getBugReportTemplate()}
					></textarea>
					<button
						class="button button-secondary copy-button"
						@click=${this.copyTemplate}
					>
						Copy Template
					</button>
				</div>

				<div class="section">
					<h4>View Error Logs</h4>
					<p>Before reporting issues, check what's happening:</p>
					<div class="button-group">
						<button class="button" @click=${this.showLogs}>
							Show Logs
						</button>
						<button class="button button-secondary download-logs" @click=${this.downloadLogs}>
							${(0, import_obsidian10.getIcon)("download")} Download Logs
						</button>
					</div>
					<div class="logs-container" id="logs-container"></div>
				</div>
			</div>
		`;
  }
  createRenderRoot() {
    return this;
  }
  showLogs() {
    const container = this.querySelector("#logs-container");
    if (!container) return;
    container.innerHTML = `
			<div class="logs-display">${JSON.stringify(retrieveScrybbleLogs(), null, 2)}</div>
		`;
  }
  copyTemplate() {
    const template = this.getBugReportTemplate();
    navigator.clipboard.writeText(template).then(() => this.showTemporaryMessage("Copied!", ".copy-button"));
  }
  downloadLogs() {
    try {
      const logs = retrieveScrybbleLogs();
      if (!logs) {
        this.showTemporaryMessage("No logs available to download", ".download-logs");
        return;
      }
      const logContent = JSON.stringify(logs, null, 2);
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = `scrybble-logs-${timestamp}.json`;
      const blob = new Blob([logContent], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a3 = document.createElement("a");
      a3.href = url;
      a3.download = filename;
      a3.style.display = "none";
      document.body.appendChild(a3);
      a3.click();
      document.body.removeChild(a3);
      URL.revokeObjectURL(url);
      this.showTemporaryMessage("Logs downloaded successfully", ".download-logs");
    } catch (error) {
      console.error("Error downloading logs:", error);
      this.showTemporaryMessage("Error downloading logs", ".download-logs");
    }
  }
  showTemporaryMessage(message, btnClass) {
    const button = this.querySelector(btnClass);
    if (button) {
      const originalText = button.innerHTML;
      button.innerHTML = message;
      button.disabled = true;
      setTimeout(() => {
        button.innerHTML = originalText;
        button.disabled = false;
      }, 2e3);
    }
  }
  getEnvironment() {
    return `- Obsidian version: ${this.scrybble.meta.obsidianVersion}
- Scrybble version: ${this.scrybble.meta.scrybbleVersion}
- Platform: ${this.scrybble.meta.platformInfo};
- Email: ${this.scrybble.authentication.user?.user.email ?? "Please type your Scrybble e-mail here"}`;
  }
  getBugReportTemplate() {
    return `**What happened:**
[Describe the issue]

**Steps to reproduce:**
1. 
2. 
3. 

**Expected behavior:**
[What should have happened]

**Environment:**
${this.getEnvironment()}

**Error logs:**
[Attach the downloaded error logs to the e-mail if possible]

**Additional context:**
[Any other relevant information]`;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ type: Object, attribute: false })
], SupportPage.prototype, "scrybble", 2);

// src/ui/Pages/AccountPage.ts
var import_obsidian11 = require("obsidian");
var AccountPage = class extends i4 {
  constructor() {
    super(...arguments);
    this.authState = "INIT" /* INIT */;
    this.error = null;
    this.copySuccess = false;
    this.stateChangeHandler = (newState) => {
      this.authState = newState;
      this.requestUpdate();
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    this.authState = this.scrybble.authentication.getState();
    this.scrybble.authentication.addStateChangeListener(this.stateChangeHandler);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
  render() {
    const errorTemplate = this.error ? x`
			<error-view .error="${this.error}" .actions="${[
      x`
					<button class="retry" @click="${() => this.handleErrorRetry()}">Retry</button>`
    ]}"></error-view>
		` : E;
    return x`
			<div class="account-container">
				${errorTemplate}
				${this.error ? E : this.renderStateBasedContent()}
			</div>
		`;
  }
  createRenderRoot() {
    return this;
  }
  renderStateBasedContent() {
    switch (this.authState) {
      case "INIT" /* INIT */:
        return this.renderLoadingView("Initializing...");
      case "REQUESTING_DEVICE_CODE" /* REQUESTING_DEVICE_CODE */:
        return this.renderLoadingView("Preparing authentication...");
      case "WAITING_FOR_USER_AUTHORIZATION" /* WAITING_FOR_USER_AUTHORIZATION */:
      case "POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */:
        return this.renderDeviceAuthorizationView();
      case "FETCHING_USER" /* FETCHING_USER */:
        return this.renderLoadingView("Fetching user information...");
      case "REFRESHING_TOKEN" /* REFRESHING_TOKEN */:
        return this.renderLoadingView("Refreshing authentication...");
      case "AUTHENTICATED" /* AUTHENTICATED */:
        return this.renderAuthenticatedView();
      case "UNAUTHENTICATED" /* UNAUTHENTICATED */:
        return this.renderLoginView();
      default:
        return x`
					<div>Unknown state: ${this.authState}</div>`;
    }
  }
  async startDeviceFlow() {
    pino.info("Starting Device Authorization flow");
    try {
      this.error = null;
      await this.scrybble.authentication.initiateDeviceFlow();
    } catch (error) {
      this.error = Errors.handle("DEVICE_AUTH_INITIATION_ERROR", error);
    }
  }
  async handleLogout() {
    await this.scrybble.authentication.logout();
  }
  async handleErrorRetry() {
    pino.info("Retrying after error");
    this.error = null;
  }
  async copyUserCode() {
    const success = await this.scrybble.authentication.copyUserCodeToClipboard();
    if (success) {
      this.copySuccess = true;
      setTimeout(() => {
        this.copySuccess = false;
        this.requestUpdate();
      }, 2e3);
      this.requestUpdate();
    }
  }
  openVerificationUrl() {
    this.scrybble.authentication.openVerificationUrl();
  }
  async cancelDeviceFlow() {
    await this.scrybble.authentication.cancelDeviceFlow();
  }
  formatDate(dateString) {
    try {
      return new Date(dateString).toLocaleDateString();
    } catch (error) {
      pino.warn({ dateString, error });
      return "Unknown";
    }
  }
  renderLoadingView(message = "Loading...") {
    return x`
			<div class="account-card">
				<div class="loading-container">
					<div class="spinner">
						${(0, import_obsidian11.getIcon)("loader-2")}
					</div>
					<p>${message}</p>
				</div>
			</div>
		`;
  }
  renderDeviceAuthorizationView() {
    const deviceAuth = this.scrybble.authentication.deviceAuth;
    if (!deviceAuth) {
      return this.renderLoadingView("Loading authorization...");
    }
    const isPolling = this.authState === "POLLING_FOR_TOKEN" /* POLLING_FOR_TOKEN */;
    return x`
			<div class="account-card">
				<div class="device-auth-header">
					<h2>Complete Authorization</h2>
					<p>To connect your Scrybble account, follow these steps:</p>
				</div>

				<div class="device-auth-steps">
					<div class="step ${isPolling ? "step-completed" : ""}">
						<div class="step-number">1</div>
						<div class="step-content">
							<h3>Open the authorization page</h3>
							<p>Click the button below to open the authorization page in your browser:</p>
							<button
								class="verification-url-button"
								@click="${this.openVerificationUrl}">
								<div class="button-icon">${(0, import_obsidian11.getIcon)("external-link")}</div>
								<span>Open Authorization Page</span>
							</button>
							<div class="url-display">
								<code>${deviceAuth.verification_uri}</code>
							</div>
						</div>
					</div>

					<div class="step ${isPolling ? "step-completed" : ""}">
						<div class="step-number">2</div>
						<div class="step-content">
							<h3>Enter the verification code</h3>
							<p>On the authorization page, enter this code:</p>
							<div class="code-display">
								<div class="user-code">
									<code>${deviceAuth.user_code}</code>
									<button
										class="copy-code-button ${this.copySuccess ? "success" : ""}"
										@click="${this.copyUserCode}"
										title="Copy verification code">
										${this.copySuccess ? x`
												<div class="button-icon">${(0, import_obsidian11.getIcon)("check")}</div>
												<span>Copied!</span>` : x`
												<div class="button-icon">${(0, import_obsidian11.getIcon)("copy")}</div><span>Copy Code</span>`}
									</button>
								</div>
								<p class="code-hint">This code expires in ${Math.floor(deviceAuth.expires_in / 60)}
									minutes</p>
							</div>
						</div>
					</div>

					<div class="step ${isPolling ? "step-active" : ""}">
						<div class="step-number">
							${isPolling ? x`
								<div class="step-spinner">${(0, import_obsidian11.getIcon)("loader-circle")}</div>` : "3"}
						</div>
						<div class="step-content">
							<h3>${isPolling ? "Waiting for authorization..." : "Return here"}</h3>
							${isPolling ? x`
									<p>Please complete the authorization process in your browser.</p>
									<div class="polling-status">
										<p>This window will update automatically once authorization is complete.</p>
									</div>
								` : x`<p>After authorizing in your browser, this page will automatically update. Keep
									this window open!</p>`}
						</div>
					</div>
				</div>

				<div class="device-auth-actions">
					<button
						class="cancel-button"
						@click="${this.cancelDeviceFlow}">
						<div class="button-icon">${(0, import_obsidian11.getIcon)("x")}</div>
						<span>Cancel</span>
					</button>
				</div>

				<div class="device-auth-help">
					<details>
						<summary>Need help?</summary>
						<div class="help-content">
							<p><strong>The authorization page didn't open?</strong></p>
							<p>Manually go to: <code>${deviceAuth.verification_uri}</code></p>

							<p><strong>Having trouble copying the code?</strong></p>
							<p>Manually type: <strong>${deviceAuth.user_code}</strong></p>

							<p><strong>Code not working?</strong></p>
							<p>Make sure you're logged into the correct Scrybble account in your browser.</p>
						</div>
					</details>
				</div>
			</div>
		`;
  }
  renderLoginView() {
    return x`
			<div class="account-card">
				<div class="account-header">
					<h2>Connect to Scrybble</h2>
					<p>Sign in to sync your ReMarkable highlights with Obsidian</p>
				</div>

				<div class="account-actions">
					<button
						class="primary-button"
						@click="${this.startDeviceFlow}">
						${(0, import_obsidian11.getIcon)("log-in")}
						<span>Sign in with Scrybble</span>
					</button>
				</div>
			</div>
		`;
  }
  formatGumroadSubscriptionManageUrl() {
    const user = this.scrybble.authentication.user;
    if (!user) return "";
    if (!user.subscription_status?.licenseInformation?.subscription_id) {
      pino.warn("Missing subscription ID for Gumroad URL");
      return "#";
    }
    return `https://gumroad.com/subscriptions/${user.subscription_status.licenseInformation.subscription_id}/manage`;
  }
  renderAuthenticatedView() {
    const userInfo = this.scrybble.authentication.user;
    if (!userInfo) {
      return this.renderLoadingView("Loading user information...");
    }
    return x`
			<div class="account-card">
				<div class="account-header authenticated">
					<div class="header-top">
						<div>
							<h2>Welcome back ${userInfo.user.name}</h2>
							<p>You're connected to Scrybble</p>
						</div>
					</div>
				</div>

				<div class="user-info-section">
					<div class="info-grid">
						<div class="info-item">
							<div class="info-label">
								${(0, import_obsidian11.getIcon)("user")}
								<span>Name</span>
							</div>
							<div class="info-value">${userInfo.user.name}</div>
						</div>

						<div class="info-item">
							<div class="info-label">
								${(0, import_obsidian11.getIcon)("mail")}
								<span>Email</span>
							</div>
							<div class="info-value">${userInfo.user.email}</div>
						</div>

						<div class="info-item">
							<div class="info-label">
								${(0, import_obsidian11.getIcon)("sunrise")}
								<span>Member since</span>
							</div>
							<div class="info-value">${this.formatDate(userInfo.user.created_at)}</div>
						</div>

						<div class="info-item">
							<div class="info-label">
								${(0, import_obsidian11.getIcon)("bird")}
								<span>Onboarding status</span>
							</div>
							<div class="info-value">${userInfo.onboarding_state}</div>
						</div>

						<div class="info-item">
							<div class="info-label">
								${(0, import_obsidian11.getIcon)("crown")}
								<span>Subscription 
									${userInfo.subscription_status?.exists ? x`<a href="${this.formatGumroadSubscriptionManageUrl()}" target="_blank">Manage</a>` : E}
								</span>
							</div>
							${userInfo.subscription_status?.lifetime ? x`
									<div class="info-value subscription-status-lifetime">Lifetime license!</div>` : x`
									<div
										class="info-value ${userInfo.subscription_status?.exists ? "subscription-status-active" : "subscription-status-inactive"}">
										${userInfo.subscription_status?.exists ? x`Active` : x`No active license`}
									</div>`}
						</div>
					</div>
				</div>

				<div class="account-stats">
					<h3>Sync Statistics</h3>
					<div class="stats-grid">
						<div class="stat-item">
							<div class="stat-icon">
								${(0, import_obsidian11.getIcon)("file-text")}
							</div>
							<div class="stat-content">
								<div class="stat-number">${userInfo.total_syncs}</div>
								<div class="stat-label">Documents synced</div>
							</div>
						</div>
					</div>
				</div>

				<button
					class="logout-button"
					@click="${this.handleLogout}"
					title="Sign out">
					${(0, import_obsidian11.getIcon)("log-out")} Log out
				</button>
			</div>
		`;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ attribute: false })
], AccountPage.prototype, "scrybble", 2);
__decorateClass([
  r5()
], AccountPage.prototype, "authState", 2);
__decorateClass([
  r5()
], AccountPage.prototype, "error", 2);
__decorateClass([
  r5()
], AccountPage.prototype, "copySuccess", 2);

// src/ui/Pages/OnboardingPage.ts
var ScrybbleOnboarding = class extends i4 {
  constructor() {
    super(...arguments);
    this.error = null;
    this.isLoading = false;
    this.license = "";
    this.oneTimeCode = "";
    this.feedback = "";
  }
  get onboardingState() {
    return this.scrybble.authentication.user.onboarding_state;
  }
  set onboardingState(state) {
    this.scrybble.authentication.user.onboarding_state = state;
  }
  resetFeedbackAndErrors() {
    if (this.error) {
      this.error = null;
    }
    if (this.feedback) {
      this.feedback = "";
    }
  }
  render() {
    if (!this.onboardingState) {
      return x`
				<div class="loading-container">Loading onboarding...</div>`;
    }
    let view;
    switch (this.onboardingState) {
      case "setup-gumroad":
        view = this.renderGumroadLicense();
        break;
      case "setup-one-time-code":
        view = this.renderOneTimeCode(true);
        break;
      case "setup-one-time-code-again":
        view = this.renderOneTimeCode(false);
        break;
      case "ready":
        view = this.renderReadyState();
        break;
      default:
        view = x`
					<div>Unknown onboarding state: ${this.onboardingState}</div>`;
    }
    return x`
			<div class="account-container">
				${this.feedback ? x`
					<div class="account-error">
						<span class="error-icon">⚠️</span>
						${this.feedback}
					</div>
				` : ""}
				<error-view .error=${this.error}></error-view>
				 
				${view}
			</div>`;
  }
  createRenderRoot() {
    return this;
  }
  async handleStateChange() {
    try {
      this.onboardingState = await this.scrybble.api.fetchOnboardingState();
      if (this.onboardingState === "ready") {
        this.onboardingReady();
      }
    } catch (e7) {
      this.error = Errors.handle("GENERAL_ERROR", e7);
    }
  }
  async handleLicenseSubmit(e7) {
    e7.preventDefault();
    if (!this.license.trim()) {
      this.feedback = "Please enter your license key";
      return;
    }
    this.isLoading = true;
    this.error = null;
    try {
      const response = await this.scrybble.api.sendGumroadLicense(this.license.trim());
      if ("error" in response) {
        if (response.error.includes("not found")) {
          this.feedback = response.error;
        } else {
          this.error = Errors.handle("GENERAL_ERROR", new Error(response.error));
        }
      } else {
        this.onboardingState = response.newState;
        await this.handleStateChange();
      }
    } catch (e8) {
      this.error = Errors.handle("GENERAL_ERROR", new Error("Failed to submit license"));
    } finally {
      this.isLoading = false;
    }
  }
  async handleOneTimeCodeSubmit(e7) {
    e7.preventDefault();
    if (!this.oneTimeCode.trim()) {
      this.feedback = "Please enter your one-time code";
      return;
    }
    if (this.oneTimeCode.length !== 8) {
      this.feedback = "Code must be exactly 8 characters";
      return;
    }
    if (!/^[a-z]{8}$/.test(this.oneTimeCode)) {
      this.feedback = "Code must contain only lowercase letters";
      return;
    }
    this.isLoading = true;
    this.resetFeedbackAndErrors();
    try {
      const response = await this.scrybble.api.sendOneTimeCode(this.oneTimeCode.trim());
      if ("error" in response) {
        this.error = Errors.handle("GENERAL_ERROR", new Error(response.error));
      } else {
        this.onboardingState = response.newState;
        await this.handleStateChange();
      }
    } catch (e8) {
      this.error = Errors.handle("GENERAL_ERROR", new Error(e8 instanceof Error ? e8.message : "Failed to submit code"));
    } finally {
      this.isLoading = false;
    }
  }
  handleLicenseInputChange(e7) {
    const target = e7.target;
    this.license = target.value;
    this.resetFeedbackAndErrors();
  }
  handleCodeInputChange(e7) {
    const target = e7.target;
    this.oneTimeCode = target.value.toLowerCase();
    this.resetFeedbackAndErrors();
  }
  renderGumroadLicense() {
    return x`
			<div class="account-card">
				<div class="account-header">
					<h2>Connect your gumroad license
						<span class="onboarding-step-indicator">(step 1/2)</span>
					</h2>
					<p>Enter your license key to get started with Scrybble</p>
				</div>

				<form @submit="${this.handleLicenseSubmit}" class="onboarding-form">
					<div class="onboarding-input-group">
						<input
							type="text"
							class="onboarding-input ${this.feedback ? "input-error" : ""}"
							required
							placeholder="Your license key"
							.value="${this.license}"
							@input="${this.handleLicenseInputChange}"
							?disabled="${this.isLoading}"
						/>
						<button
							class="primary-button"
							type="submit"
							?disabled="${this.isLoading || !this.license.trim()}"
						>
							${this.isLoading ? "Submitting..." : "Submit"}
						</button>
					</div>
				</form>

				<div class="onboarding-divider"></div>

				<div class="onboarding-help">
					<a
						href="https://streamsoft.gumroad.com/l/remarkable-to-obsidian"
						class="onboarding-link"
						target="_blank"
					>
						Don't have a license? Try scrybble for free
					</a>
					<p class="onboarding-help-text">The first month is on us. You can cancel at any time.</p>
				</div>
			</div>
		`;
  }
  renderOneTimeCode(firstTime) {
    return x`
			<div class="account-card">
				<div class="account-header">
					<h2>Connect with reMarkable
						${firstTime ? x`<span class="onboarding-step-indicator">(step 2/2)</span>` : ""}
					</h2>
					<p>Authenticate with your reMarkable device</p>
				</div>

				${!firstTime ? x`
					<div class="account-error">
						<span class="error-icon">⚠️</span>
						Your authentication token has expired, please log in with reMarkable again
					</div>
				` : ""}

				<div class="onboarding-instructions">
					<p>
						Retrieve your
						<a
							target="_blank"
							href="https://my.remarkable.com/device/desktop/connect"
							class="onboarding-link"
						>
							one-time-code
						</a>
						and fill it in below
					</p>

					<div class="onboarding-note">
						<strong>Note:</strong> connecting ${firstTime ? "for the first time " : ""}may take
						<em>well over a minute!</em>
					</div>
				</div>

				<form @submit="${this.handleOneTimeCodeSubmit}" class="onboarding-form">
					<div class="onboarding-input-group">
						<input
							class="onboarding-input onboarding-code-input ${this.feedback ? "input-error" : ""}"
							required
							minlength="8"
							maxlength="8"
							pattern="[a-z]{8}"
							placeholder="aabbccdd"
							type="text"
							autofocus
							.value="${this.oneTimeCode}"
							@input="${this.handleCodeInputChange}"
							?disabled="${this.isLoading}"
						/>
						<button
							class="primary-button"
							type="submit"
							?disabled="${this.isLoading || this.oneTimeCode.length !== 8}"
						>
							${this.isLoading ? x`
								<span class="onboarding-spinner"></span>
								Checking code...
							` : "Submit"}
						</button>
					</div>
				</form>
			</div>
		`;
  }
  renderReadyState() {
    return x`
			<div class="account-card">
				<div class="onboarding-completion">
					<div class="completion-icon">
						<div class="success-checkmark">✓</div>
					</div>

					<div class="completion-content">
						<h2>Setup complete</h2>
						<p>Your Scrybble connection is ready. You can now browse your reMarkable files and sync them
							to Obsidian.</p>

						<div class="next-steps">
							<div class="step-hint">
								<span class="hint-icon">→</span>
								<span>Browse your files using the <strong>Files</strong> tab above</span>
							</div>
						</div>
					</div>
				</div>
			</div>
		`;
  }
};
__decorateClass([
  c4({ context: scrybbleContext }),
  n5({ type: Object, attribute: false })
], ScrybbleOnboarding.prototype, "scrybble", 2);
__decorateClass([
  n5({ type: String })
], ScrybbleOnboarding.prototype, "onboardingReady", 2);
__decorateClass([
  r5()
], ScrybbleOnboarding.prototype, "error", 2);
__decorateClass([
  r5()
], ScrybbleOnboarding.prototype, "isLoading", 2);
__decorateClass([
  r5()
], ScrybbleOnboarding.prototype, "license", 2);
__decorateClass([
  r5()
], ScrybbleOnboarding.prototype, "oneTimeCode", 2);
__decorateClass([
  r5()
], ScrybbleOnboarding.prototype, "feedback", 2);

// src/ui/loadComponents.ts
var import_obsidian12 = require("obsidian");
function loadLitComponents() {
  if (!window.customElements.get("rm-tree")) {
    window.customElements.define("rm-tree", RmFileTree);
  }
  if (!window.customElements.get("rm-file")) {
    window.customElements.define("rm-file", RmFile);
  }
  if (!window.customElements.get("rm-dir")) {
    window.customElements.define("rm-dir", RmDir);
  }
  if (!window.customElements.get("scrybble-file-tree")) {
    window.customElements.define("scrybble-file-tree", ScrybbleFileTreeComponent);
  }
  if (!window.customElements.get("error-view")) {
    window.customElements.define("error-view", ErrorComponent);
  }
  if (!window.customElements.get("sync-progress-indicator")) {
    window.customElements.define("sync-progress-indicator", SyncProgressIndicator);
  }
  if (!window.customElements.get("scrybble-ui")) {
    window.customElements.define("scrybble-ui", ScrybbleUI);
  }
  if (!window.customElements.get("scrybble-support")) {
    window.customElements.define("scrybble-support", SupportPage);
  }
  if (!window.customElements.get("scrybble-account")) {
    window.customElements.define("scrybble-account", AccountPage);
  }
  if (!window.customElements.get("scrybble-onboarding")) {
    window.customElements.define("scrybble-onboarding", ScrybbleOnboarding);
  }
  if ((0, import_obsidian12.getIcon)("file-x-2") == null) {
    (0, import_obsidian12.addIcon)("file-x-2", `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-x2-icon lucide-file-x-2"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="m8 12.5-5 5"/><path d="m3 12.5 5 5"/></svg>`);
  }
}

// src/SyncQueue.ts
var import_obsidian13 = require("obsidian");

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = (function(c5, id, msg, transfer, cb) {
  var w2 = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c5 + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w2.onmessage = function(e7) {
    var d3 = e7.data, ed = d3.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d3);
  };
  w2.postMessage(msg, transfer);
  return w2;
});
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b3 = new u16(31);
  for (var i6 = 0; i6 < 31; ++i6) {
    b3[i6] = start += 1 << eb[i6 - 1];
  }
  var r6 = new i32(b3[30]);
  for (var i6 = 1; i6 < 30; ++i6) {
    for (var j2 = b3[i6]; j2 < b3[i6 + 1]; ++j2) {
      r6[j2] = j2 - b3[i6] << 5 | i6;
    }
  }
  return { b: b3, r: r6 };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i6 = 0; i6 < 32768; ++i6) {
  x2 = (i6 & 43690) >> 1 | (i6 & 21845) << 1;
  x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
  rev[i6] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
}
var x2;
var i6;
var hMap = (function(cd, mb, r6) {
  var s7 = cd.length;
  var i6 = 0;
  var l3 = new u16(mb);
  for (; i6 < s7; ++i6) {
    if (cd[i6])
      ++l3[cd[i6] - 1];
  }
  var le = new u16(mb);
  for (i6 = 1; i6 < mb; ++i6) {
    le[i6] = le[i6 - 1] + l3[i6 - 1] << 1;
  }
  var co;
  if (r6) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i6 = 0; i6 < s7; ++i6) {
      if (cd[i6]) {
        var sv = i6 << 4 | cd[i6];
        var r_1 = mb - cd[i6];
        var v2 = le[cd[i6] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s7);
    for (i6 = 0; i6 < s7; ++i6) {
      if (cd[i6]) {
        co[i6] = rev[le[cd[i6] - 1]++] >> 15 - cd[i6];
      }
    }
  }
  return co;
});
var flt = new u8(288);
for (i6 = 0; i6 < 144; ++i6)
  flt[i6] = 8;
var i6;
for (i6 = 144; i6 < 256; ++i6)
  flt[i6] = 9;
var i6;
for (i6 = 256; i6 < 280; ++i6)
  flt[i6] = 7;
var i6;
for (i6 = 280; i6 < 288; ++i6)
  flt[i6] = 8;
var i6;
var fdt = new u8(32);
for (i6 = 0; i6 < 32; ++i6)
  fdt[i6] = 5;
var i6;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a3) {
  var m2 = a3[0];
  for (var i6 = 1; i6 < a3.length; ++i6) {
    if (a3[i6] > m2)
      m2 = a3[i6];
  }
  return m2;
};
var bits = function(d3, p4, m2) {
  var o6 = p4 / 8 | 0;
  return (d3[o6] | d3[o6 + 1] << 8) >> (p4 & 7) & m2;
};
var bits16 = function(d3, p4) {
  var o6 = p4 / 8 | 0;
  return (d3[o6] | d3[o6 + 1] << 8 | d3[o6 + 2] << 16) >> (p4 & 7);
};
var shft = function(p4) {
  return (p4 + 7) / 8 | 0;
};
var slc = function(v2, s7, e7) {
  if (s7 == null || s7 < 0)
    s7 = 0;
  if (e7 == null || e7 > v2.length)
    e7 = v2.length;
  return new u8(v2.subarray(s7, e7));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e7 = new Error(msg || ec[ind]);
  e7.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e7, err);
  if (!nt)
    throw e7;
  return e7;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l4) {
    var bl = buf.length;
    if (l4 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l4));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s7 = shft(pos) + 4, l3 = dat[s7 - 4] | dat[s7 - 3] << 8, t6 = s7 + l3;
        if (t6 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l3);
        buf.set(dat.subarray(s7, t6), bt);
        st.b = bt += l3, st.p = pos = t6 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i6 = 0; i6 < hcLen; ++i6) {
          clt[clim[i6]] = bits(dat, pos + i6 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i6 = 0; i6 < tl; ) {
          var r6 = clm[bits(dat, pos, clbmsk)];
          pos += r6 & 15;
          var s7 = r6 >> 4;
          if (s7 < 16) {
            ldt[i6++] = s7;
          } else {
            var c5 = 0, n7 = 0;
            if (s7 == 16)
              n7 = 3 + bits(dat, pos, 3), pos += 2, c5 = ldt[i6 - 1];
            else if (s7 == 17)
              n7 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s7 == 18)
              n7 = 11 + bits(dat, pos, 127), pos += 7;
            while (n7--)
              ldt[i6++] = c5;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c5 = lm[bits16(dat, pos) & lms], sym = c5 >> 4;
      pos += c5 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c5)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i6 = sym - 257, b3 = fleb[i6];
          add = bits(dat, pos, (1 << b3) - 1) + fl[i6];
          pos += b3;
        }
        var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >> 4;
        if (!d3)
          err(3);
        pos += d3 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b3 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b3) - 1, pos += b3;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var mrg = function(a3, b3) {
  var o6 = {};
  for (var k2 in a3)
    o6[k2] = a3[k2];
  for (var k2 in b3)
    o6[k2] = b3[k2];
  return o6;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i6 = 0; i6 < dt.length; ++i6) {
    var v2 = dt[i6], k2 = ks[i6];
    if (typeof v2 == "function") {
      fnStr += ";" + k2 + "=";
      var st_1 = v2.toString();
      if (v2.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t6 in v2.prototype)
            fnStr += ";" + k2 + ".prototype." + t6 + "=" + v2.prototype[t6].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k2] = v2;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v2) {
  var tl = [];
  for (var k2 in v2) {
    if (v2[k2].buffer) {
      tl.push((v2[k2] = new v2[k2].constructor(v2[k2])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init, id, cb) {
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m2 = fns.length - 1;
    for (var i6 = 0; i6 < m2; ++i6)
      fnStr = wcln(fns[i6], fnStr, td_1);
    ch[id] = { c: wcln(fns[m2], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id].e);
  return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o6) {
  return o6 && {
    out: o6.size && new u8(o6.size),
    dictionary: o6.dictionary
  };
};
var cbify = function(dat, opts, fns, init, id, cb) {
  var w2 = wrkr(fns, init, id, function(err2, dat2) {
    w2.terminate();
    cb(err2, dat2);
  });
  w2.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function() {
    w2.terminate();
  };
};
var b22 = function(d3, b3) {
  return d3[b3] | d3[b3 + 1] << 8;
};
var b4 = function(d3, b3) {
  return (d3[b3] | d3[b3 + 1] << 8 | d3[b3 + 2] << 16 | d3[b3 + 3] << 24) >>> 0;
};
var b8 = function(d3, b3) {
  return b4(d3, b3) + b4(d3, b3 + 4) * 4294967296;
};
function inflate(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  return cbify(data, opts, [
    bInflt
  ], function(ev) {
    return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
  }, 1, cb);
}
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e7) {
}
var dutf8 = function(d3) {
  for (var r6 = "", i6 = 0; ; ) {
    var c5 = d3[i6++];
    var eb = (c5 > 127) + (c5 > 223) + (c5 > 239);
    if (i6 + eb > d3.length)
      return { s: r6, r: slc(d3, i6 - 1) };
    if (!eb)
      r6 += String.fromCharCode(c5);
    else if (eb == 3) {
      c5 = ((c5 & 15) << 18 | (d3[i6++] & 63) << 12 | (d3[i6++] & 63) << 6 | d3[i6++] & 63) - 65536, r6 += String.fromCharCode(55296 | c5 >> 10, 56320 | c5 & 1023);
    } else if (eb & 1)
      r6 += String.fromCharCode((c5 & 31) << 6 | d3[i6++] & 63);
    else
      r6 += String.fromCharCode((c5 & 15) << 12 | (d3[i6++] & 63) << 6 | d3[i6++] & 63);
  }
};
function strFromU8(dat, latin1) {
  if (latin1) {
    var r6 = "";
    for (var i6 = 0; i6 < dat.length; i6 += 16384)
      r6 += String.fromCharCode.apply(null, dat.subarray(i6, i6 + 16384));
    return r6;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s7 = _a2.s, r6 = _a2.r;
    if (r6.length)
      err(8);
    return s7;
  }
}
var slzh = function(d3, b3) {
  return b3 + 30 + b22(d3, b3 + 26) + b22(d3, b3 + 28);
};
var zh = function(d3, b3, z2) {
  var fnl = b22(d3, b3 + 28), fn = strFromU8(d3.subarray(b3 + 46, b3 + 46 + fnl), !(b22(d3, b3 + 8) & 2048)), es = b3 + 46 + fnl, bs = b4(d3, b3 + 20);
  var _a2 = z2 && bs == 4294967295 ? z64e(d3, es) : [bs, b4(d3, b3 + 24), b4(d3, b3 + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b22(d3, b3 + 10), sc, su, fn, es + b22(d3, b3 + 30) + b22(d3, b3 + 32), off];
};
var z64e = function(d3, b3) {
  for (; b22(d3, b3) != 1; b3 += 4 + b22(d3, b3 + 2))
    ;
  return [b8(d3, b3 + 12), b8(d3, b3 + 4), b8(d3, b3 + 20)];
};
var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
  fn();
};
function unzip(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  var term = [];
  var tAll = function() {
    for (var i7 = 0; i7 < term.length; ++i7)
      term[i7]();
  };
  var files = {};
  var cbd = function(a3, b3) {
    mt(function() {
      cb(a3, b3);
    });
  };
  mt(function() {
    cbd = cb;
  });
  var e7 = data.length - 22;
  for (; b4(data, e7) != 101010256; --e7) {
    if (!e7 || data.length - e7 > 65558) {
      cbd(err(13, 0, 1), null);
      return tAll;
    }
  }
  ;
  var lft = b22(data, e7 + 8);
  if (lft) {
    var c5 = lft;
    var o6 = b4(data, e7 + 16);
    var z2 = o6 == 4294967295 || c5 == 65535;
    if (z2) {
      var ze = b4(data, e7 - 12);
      z2 = b4(data, ze) == 101075792;
      if (z2) {
        c5 = lft = b4(data, ze + 32);
        o6 = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    var _loop_3 = function(i7) {
      var _a2 = zh(data, o6, z2), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b3 = slzh(data, off);
      o6 = no;
      var cbl = function(e8, d3) {
        if (e8) {
          tAll();
          cbd(e8, null);
        } else {
          if (d3)
            files[fn] = d3;
          if (!--lft)
            cbd(null, files);
        }
      };
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_1
      })) {
        if (!c_1)
          cbl(null, slc(data, b3, b3 + sc));
        else if (c_1 == 8) {
          var infl = data.subarray(b3, b3 + sc);
          if (su < 524288 || sc > 0.8 * su) {
            try {
              cbl(null, inflateSync(infl, { out: new u8(su) }));
            } catch (e8) {
              cbl(e8, null);
            }
          } else
            term.push(inflate(infl, { size: su }, cbl));
        } else
          cbl(err(14, "unknown compression type " + c_1, 1), null);
      } else
        cbl(null, null);
    };
    for (var i6 = 0; i6 < c5; ++i6) {
      _loop_3(i6);
    }
  } else
    cbd(null, {});
  return tAll;
}

// src/SyncQueue.ts
var import_path2 = __toESM(require_path_browserify());
var SyncQueue = class {
  constructor(settings, vault, api, onStartDownloadFile, onFinishedDownloadFile) {
    this.settings = settings;
    this.vault = vault;
    this.api = api;
    this.onStartDownloadFile = onStartDownloadFile;
    this.onFinishedDownloadFile = onFinishedDownloadFile;
    this.syncJobs = [];
    this.busyStates = ["DOWNLOADING" /* downloading */, "AWAITING_PROCESSING" /* awaiting_processing */];
    this.syncJobStateChangeListeners = /* @__PURE__ */ new Map();
    setInterval(async () => {
      const maxActiveJobs = 3;
      let busy = this.countBusyJobs();
      for (let job of this.syncJobs) {
        if (job.getState() === "DOWNLOADING" /* downloading */ || job.getState() === "AWAITING_PROCESSING" /* awaiting_processing */) {
          busy += 1;
        }
        if (busy < maxActiveJobs) {
          if (job.getState() === "INIT" /* init */) {
            await this.requestFileToBeSynced(job);
            busy += 1;
          } else if (job.getState() === "READY_TO_DOWNLOAD" /* ready_to_download */) {
            const file = await this.download(job);
            if (file) {
              await this.writeDownloadedZip(job, file);
            }
            busy += 1;
          } else if (job.getState() === "PROCESSING" /* processing */) {
            await this.checkProcessingState(job);
            busy += 1;
          }
        }
      }
    }, 2e3);
  }
  syncjobStateChangeListener(path3, newState, job) {
    if (this.syncJobStateChangeListeners.has(path3)) {
      const listeners = this.syncJobStateChangeListeners.get(path3) ?? [];
      for (let listener of listeners) {
        listener(newState, job);
      }
    }
  }
  subscribeToSyncStateChangesForFile(path3, callback) {
    if (this.syncJobStateChangeListeners.has(path3)) {
      this.syncJobStateChangeListeners.get(path3).push(callback);
    } else {
      this.syncJobStateChangeListeners.set(path3, [callback]);
    }
  }
  unsubscribeToSyncStateChangesForFile(path3) {
    this.syncJobStateChangeListeners.delete(path3);
  }
  async downloadProcessedFile(filename, download_url, sync_id) {
    const syncJob = new SyncJob(0, "INIT" /* init */, this.syncjobStateChangeListener.bind(this), filename);
    await syncJob.readyToDownload(download_url, sync_id);
    this.syncJobs.push(syncJob);
  }
  requestSync(filename) {
    const job = new SyncJob(0, "INIT" /* init */, this.syncjobStateChangeListener.bind(this), filename);
    this.syncJobs.push(job);
  }
  countBusyJobs() {
    return this.syncJobs.filter((job) => this.busyStates.contains(job.getState())).length;
  }
  async download(job) {
    try {
      this.onStartDownloadFile(job);
      await job.startDownload();
      return await (0, import_obsidian13.requestUrl)({
        method: "GET",
        url: job.download_url
      }).arrayBuffer;
    } catch (e7) {
      this.onFinishedDownloadFile(job, false, e7);
      Errors.handle("FILE_DOWNLOAD_ERROR", e7);
      await job.downloadingFailed();
    }
  }
  async writeDownloadedZip(job, file) {
    let relativePath = dirPath(job.filename);
    let nameOfFile = sanitizeFilename(basename(job.filename));
    const folderPath = await this.ensureFolderExists(this.vault, relativePath, this.settings.sync_folder);
    const out_path = import_path2.default.join(folderPath, nameOfFile);
    try {
      const zipData = new Uint8Array(file);
      const unzippedFiles = await new Promise((resolve, reject) => {
        unzip(zipData, (err2, unzipped) => {
          if (err2) reject(err2);
          else resolve(unzipped);
        });
      });
      await this.extractFileFromZip(this.vault, unzippedFiles, /_remarks(-only)?.pdf/, `${out_path}.pdf`);
      await this.extractFileFromZip(this.vault, unzippedFiles, /_obsidian.md/, `${out_path}.md`, false);
      await job.downloaded();
      this.onFinishedDownloadFile(job, true);
    } catch (e7) {
      this.onFinishedDownloadFile(job, false, e7);
      Errors.handle("ZIP_EXTRACT_ERROR", e7);
      await job.downloadingFailed();
      return;
    }
  }
  async writeToFile(vault, filePath, data) {
    const file = vault.getAbstractFileByPath(filePath);
    if (file === null) {
      try {
        await vault.createBinary(filePath, data);
      } catch {
        throw new Error(`Scrybble: Was unable to write file ${filePath}, reference = 104`);
      }
    } else if (file instanceof import_obsidian13.TFile) {
      try {
        await vault.modifyBinary(file, data);
      } catch {
        throw new Error(`Scrybble: Was unable to modify file ${filePath}, reference = 105`);
      }
    } else {
      throw new Error("Scrybble: Unknown error reference = 103");
    }
  }
  async ensureFolderExists(vault, relativePath, sync_folder) {
    let folderPath = relativePath.startsWith("/") ? `${sync_folder}${relativePath}` : `${sync_folder}/${relativePath}`;
    folderPath = folderPath.split("/").map((folderName) => sanitizeFilename(folderName, true)).join("/");
    try {
      await vault.createFolder(folderPath);
    } catch (e7) {
      if (e7 instanceof Error && !e7.message.includes("already exists")) {
        Errors.handle("UNABLE_TO_CREATE_FOLDER", e7);
      }
    }
    return folderPath;
  }
  async extractFileFromZip(vault, unzippedFiles, nameMatch, vaultFileName, required = true) {
    const matchingFile = Object.keys(unzippedFiles).find((filename) => nameMatch.test(filename));
    if (!matchingFile) {
      if (required) {
        throw new Error("Scrybble: Missing file in downloaded sync zip, reference = 106");
      }
      return;
    }
    const data = unzippedFiles[matchingFile].buffer;
    try {
      await this.writeToFile(vault, vaultFileName, data);
    } catch (e7) {
      throw new Error(`Scrybble: Failed to place file "${vaultFileName}" in the right location, reference = 107`);
    }
  }
  async requestFileToBeSynced(job) {
    try {
      await job.syncRequestSent();
      const response = await this.api.fetchRequestFileToBeSynced(job.filename);
      await job.syncRequestConfirmed(response.sync_id);
    } catch (e7) {
    }
  }
  async checkProcessingState(job) {
    await job.sentProcessingRequest();
    const state = await this.api.fetchSyncState(job.sync_id);
    if (state.completed) {
      await job.readyToDownload(state.download_url, state.id);
    } else if (state.error) {
      await job.processingFailed();
    } else {
      await job.fileStillProcessing();
    }
  }
};

// src/SettingsImpl.ts
var SettingsImpl = class {
  constructor(s7, saveSettings) {
    this.sync_folder = "scrybble";
    this.self_hosted = false;
    this.custom_host = {
      endpoint: "",
      client_secret: "",
      client_id: ""
    };
    this.sync_state = {};
    this.sync_folder = s7?.sync_folder ?? "scrybble/";
    this.sync_state = s7?.sync_state ?? {};
    this.self_hosted = s7?.self_hosted ?? false;
    if (s7?.custom_host) {
      this.custom_host = s7.custom_host;
    }
    if (s7?.refresh_token) {
      this.refresh_token = s7.refresh_token;
    }
    if (s7?.access_token) {
      this.access_token = s7.access_token;
    }
    this.save = saveSettings;
  }
  get endpoint() {
    if (this.self_hosted) {
      return this.custom_host.endpoint;
    } else {
      return "https://scrybble.ink";
    }
  }
  get client_id() {
    if (this.self_hosted) {
      return this.custom_host.client_id;
    }
    return "01974ab1-1afe-700a-a69b-22fe0e3334c1";
  }
  get client_secret() {
    if (this.self_hosted) {
      return this.custom_host.client_secret;
    }
    return "7OVMeOZbXJaMH2I1mKr67H6VPrW2S7PlwAneuSFQ";
  }
};

// main.ts
loadLitComponents();
var Scrybble = class extends import_obsidian14.Plugin {
  get access_token() {
    return this.settings.access_token ?? null;
  }
  get refresh_token() {
    return this.settings.refresh_token ?? null;
  }
  async onload() {
    pino.info("Loading Scrybble plugin");
    this.settings = new SettingsImpl(await this.loadData(), async () => {
      await this.saveData(this.settings);
    });
    this.authentication = new Authentication(this.settings, this);
    this.syncQueue = new SyncQueue(
      this.settings,
      this.app.vault,
      this,
      function onStartDownloadFile(job) {
      },
      (job) => {
        this.settings.sync_state[job.filename] = job.sync_id;
        this.settings.save();
      }
    );
    this.addSettingTab(new Settings(this.app, this));
    this.registerView(
      SCRYBBLE_VIEW,
      (leaf) => {
        return new ScrybbleView(leaf, this);
      }
    );
    const syncHistory = this.addStatusBarItem();
    syncHistory.addClass("mod-clickable");
    syncHistory.setText("Scrybble");
    syncHistory.onClickEvent(this.showScrybbleFiletree.bind(this));
    this.addCommand({
      id: "open-scrybble-pane",
      name: "Browse your reMarkable files",
      callback: this.showScrybbleFiletree.bind(this)
    });
    this.app.workspace.onLayoutReady(this.checkAccountStatus.bind(this));
  }
  async showScrybbleFiletree() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(SCRYBBLE_VIEW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf?.setViewState({ type: SCRYBBLE_VIEW, active: true });
    }
    if (leaf instanceof import_obsidian14.WorkspaceLeaf) {
      await workspace.revealLeaf(leaf);
    }
  }
  async authenticatedRequest(url, options = {}) {
    return (0, import_obsidian14.requestUrl)({
      ...options,
      url,
      headers: {
        ...options.headers,
        "Authorization": `Bearer ${this.access_token}`
      }
    });
  }
  async sync() {
    const latestSyncState = await this.fetchSyncDelta();
    const settings = this.settings;
    for (const { filename, id, download_url } of latestSyncState) {
      const file_not_synced_locally = !(filename in settings.sync_state);
      const file_has_update = settings.sync_state[filename] < id;
      if (file_not_synced_locally || file_has_update) {
        await this.syncQueue.downloadProcessedFile(filename, download_url, id);
      }
    }
  }
  async fetchSyncDelta() {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/delta`, {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    });
    return response.json;
  }
  async fetchFileTree(path3 = "/") {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/RMFileTree`, {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ path: path3 })
    });
    return response.json;
  }
  async fetchSyncState(sync_id) {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/status`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "accept": "application/json"
      },
      body: JSON.stringify({ sync_id })
    });
    return response.json;
  }
  async fetchRequestFileToBeSynced(filePath) {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/file`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "accept": "application/json"
      },
      body: JSON.stringify({
        file: filePath
      })
    });
    return response.json;
  }
  async fetchOnboardingState() {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/onboardingState`, {
      method: "GET",
      headers: {
        "accept": "application/json",
        "Authorization": `Bearer ${this.access_token}`
      }
    });
    return response.json;
  }
  async fetchGetUser() {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/user`, {
      method: "GET",
      headers: {
        "accept": "application/json"
      }
    });
    return { ...response.json };
  }
  async fetchDeviceCode() {
    const response = await (0, import_obsidian14.requestUrl)({
      url: `${this.settings.endpoint}/oauth/device/code`,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json"
      },
      body: new URLSearchParams({
        client_id: this.settings.client_id,
        scope: ""
      }).toString()
    });
    const data = response.json;
    if (!data.device_code || !data.user_code || !data.verification_uri) {
      throw new Error("Invalid device code response format");
    }
    return data;
  }
  async fetchPollForDeviceToken(deviceCode) {
    const response = await (0, import_obsidian14.requestUrl)({
      url: `${this.settings.endpoint}/oauth/token`,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json"
      },
      body: new URLSearchParams({
        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
        client_id: this.settings.client_id,
        device_code: deviceCode,
        client_secret: this.settings.client_secret
      }).toString(),
      throw: false
    });
    return response.json;
  }
  async fetchRefreshOAuthAccessToken() {
    pino.info(`Sending request for a refresh token with ${this.refresh_token}`);
    const formData = new URLSearchParams({
      grant_type: "refresh_token",
      client_id: this.settings.client_id,
      refresh_token: this.refresh_token,
      scope: ""
    });
    const response = await (0, import_obsidian14.requestUrl)({
      url: `${this.settings.endpoint}/oauth/token`,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json"
      },
      body: formData.toString()
    });
    return response.json;
  }
  async sendGumroadLicense(license) {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/gumroadLicense`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ license }),
      throw: false
    });
    return response.json;
  }
  async sendOneTimeCode(code) {
    const response = await this.authenticatedRequest(`${this.settings.endpoint}/api/sync/onetimecode`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ code })
    });
    return response.json;
  }
  async fetchGiveFeedback(details) {
    this.authenticatedRequest(`${this.settings.endpoint}/api/sync/remarkable-document-share`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(details)
    });
  }
  async checkAccountStatus() {
    await this.authentication.initializeAuth();
    if (this.authentication.isAuthenticated()) {
      await this.sync();
    }
  }
};
/*! Bundled license information:

lit-html/lit-html.js:
@lit/reactive-element/reactive-element.js:
lit-element/lit-element.js:
@lit/reactive-element/decorators/custom-element.js:
@lit/reactive-element/decorators/property.js:
@lit/reactive-element/decorators/state.js:
@lit/reactive-element/decorators/event-options.js:
@lit/reactive-element/decorators/base.js:
@lit/reactive-element/decorators/query.js:
@lit/reactive-element/decorators/query-all.js:
@lit/reactive-element/decorators/query-async.js:
@lit/reactive-element/decorators/query-assigned-nodes.js:
@lit/context/lib/decorators/provide.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
@lit/context/lib/context-request-event.js:
@lit/context/lib/create-context.js:
@lit/context/lib/controllers/context-consumer.js:
@lit/context/lib/value-notifier.js:
@lit/context/lib/controllers/context-provider.js:
@lit/context/lib/context-root.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/decorators/consume.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/

/* nosourcemap */